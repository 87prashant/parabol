type AcceptTeamInvitationPayload {
  error: StandardMutationError

  """The new auth token sent to the mutator"""
  authToken: ID

  """The team that the invitee will be joining"""
  team: Team

  """The new team member on the team"""
  teamMember: TeamMember

  """The invite notifications that are no longer necessary"""
  removedNotificationIds: [ID!]

  """For payloads going to the team leader that got new suggested actions"""
  teamLead: User
}

"""The phases of an action meeting"""
enum ActionMeetingPhaseEnum {
  lobby
  checkin
  updates
  firstcall
  agendaitems
  lastcall
  summary
}

"""The action-specific meeting settings"""
type ActionMeetingSettings implements TeamMeetingSettings {
  id: ID!

  """The type of meeting these settings apply to"""
  meetingType: MeetingTypeEnum

  """The broad phase types that will be addressed during the meeting"""
  phaseTypes: [NewMeetingPhaseTypeEnum!]!

  """FK"""
  teamId: ID!

  """The team these settings belong to"""
  team: Team
}

type AddAgendaItemPayload {
  agendaItem: AgendaItem
  error: StandardMutationError
}

type AddAtlassianAuthPayload {
  error: StandardMutationError

  """The newly created auth"""
  atlassianAuth: AtlassianAuth

  """The user with updated atlassianAuth"""
  user: User
}

type AddFeatureFlagPayload {
  error: StandardMutationError

  """
  the user that was given the super power. Use users instead in GraphiQL since it may affect multiple users
  """
  user: User

  """the users given the super power"""
  users: [User]

  """A human-readable result"""
  result: String
}

type AddGitHubRepoPayload {
  error: StandardMutationError
  repo: GitHubIntegration!
}

type AddNewFeaturePayload {
  """the new feature broadcast"""
  newFeature: NewFeatureBroadcast
}

type AddOrgPayload {
  organization: Organization
  error: StandardMutationError
  team: Team

  """The teamMember that just created the new team, if this is a creation"""
  teamMember: TeamMember

  """The ID of the suggestion to create a new team"""
  removedSuggestedActionId: ID
}

type AddProviderPayload {
  error: StandardMutationError
  providerRow: ProviderRow
  provider: Provider

  """All the integrationIds that the provider has successfully joined"""
  joinedIntegrationIds: [ID!]
  teamMember: TeamMember
}

type AddReflectTemplatePayload {
  error: StandardMutationError
  reflectTemplate: ReflectTemplate
}

type AddReflectTemplatePromptPayload {
  error: StandardMutationError
  prompt: RetroPhaseItem
}

input AddSlackChannelInput {
  """The id of the teamMember calling it."""
  teamMemberId: ID!

  """the slack channel that wants our messages"""
  slackChannelId: ID!
}

type AddSlackChannelPayload {
  error: StandardMutationError
  channel: SlackIntegration!
}

type AddTeamPayload {
  error: StandardMutationError
  team: Team

  """The teamMember that just created the new team, if this is a creation"""
  teamMember: TeamMember

  """The ID of the suggestion to create a new team"""
  removedSuggestedActionId: ID
}

"""A request placeholder that will likely turn into 1 or more tasks"""
type AgendaItem {
  """The unique agenda item id teamId::shortid"""
  id: ID!

  """The body of the agenda item"""
  content: String!

  """The timestamp the agenda item was created"""
  createdAt: DateTime

  """
  true until the agenda item has been marked isComplete and the meeting has ended
  """
  isActive: Boolean

  """
  true if the agenda item has been addressed in a meeting (will have a strikethrough or similar)
  """
  isComplete: Boolean

  """The sort order of the agenda item in the list"""
  sortOrder: Float!

  """*The team for this agenda item"""
  teamId: ID!

  """The teamMemberId that created this agenda item"""
  teamMemberId: ID!

  """The timestamp the agenda item was updated"""
  updatedAt: DateTime

  """The team member that created the agenda item"""
  teamMember: TeamMember
}

union AgendaItemSubscriptionPayload = AddAgendaItemPayload | RemoveAgendaItemPayload | UpdateAgendaItemPayload | MoveMeetingPayload

type ArchiveTeamPayload {
  error: StandardMutationError
  team: Team

  """
  A notification explaining that the team was archived and removed from view
  """
  notification: NotifyTeamArchived
  removedTeamNotifications: [TeamNotification]

  """all the suggested actions that never happened"""
  removedSuggestedActionIds: [ID]
}

"""The part of the site that is calling the mutation"""
enum AreaEnum {
  meeting
  teamDash
  userDash
}

interface Assignee {
  """The teamMemberId or softTeamMemberId"""
  id: ID!

  """The name of the assignee"""
  preferredName: String!

  """foreign key to Team table"""
  teamId: ID!
}

"""OAuth token for a team member"""
type AtlassianAuth {
  """shortid"""
  id: ID!

  """true if the auth is valid, else false"""
  isActive: Boolean!

  """
  The access token to atlassian, useful for 1 hour. null if no access token available
  """
  accessToken: ID

  """
  *The id for the user used by the provider, eg SlackTeamId, GoogleUserId, githubLogin
  """
  atlassianUserId: ID!

  """The atlassian cloud IDs that the user has granted"""
  cloudIds: [ID!]!

  """The timestamp the provider was created"""
  createdAt: DateTime!

  """
  The refresh token to atlassian to receive a new 1-hour accessToken, always null since server secret is required
  """
  refreshToken: ID

  """*The team that the token is linked to"""
  teamId: ID!

  """The timestamp the token was updated at"""
  updatedAt: DateTime!

  """The user that the access token is attached to"""
  userId: ID!
}

type AuthIdentityType {
  """
  The connection name.
        This field is not itself updateable
        but is needed when updating email, email_verified, username or password.
  """
  connection: String

  """The unique identifier for the user for the identity."""
  userId: ID

  """The type of identity provider."""
  provider: String

  """true if the identity provider is a social provider, false otherwise"""
  isSocial: Boolean
}

"""An auth token provided by Parabol to the client"""
type AuthToken {
  """A static ID so the location in the relay store is deterministic"""
  id: ID

  """audience. the target API used in auth0. Parabol does not use this."""
  aud: String

  """beta. 1 if enrolled in beta features. else absent"""
  bet: Int

  """expiration. Time since unix epoch / 1000"""
  exp: Float!

  """issued at. Time since unix epoch / 1000"""
  iat: Float!

  """
  issuer. the url that gave them the token. useful for detecting environment
  """
  iss: String

  """subscriber. userId"""
  sub: ID

  """role. Any privileges associated with the account"""
  rol: AuthTokenRole

  """teams. a list of teamIds where the user is active"""
  tms: [ID!]
}

"""A role describing super user privileges"""
enum AuthTokenRole {
  su
}

type AutoGroupReflectionsPayload {
  error: StandardMutationError
  meeting: RetrospectiveMeeting
  reflections: [RetroReflection]
  reflectionGroups: [RetroReflectionGroup]
  removedReflectionGroups: [RetroReflectionGroup]
}

"""Identifier and IP address blocked"""
type BlockedUserType {
  """The identifier (usually email) of blocked user"""
  identifier: String

  """The IP address of the blocked user"""
  id: String
}

type ChangeTaskTeamPayload {
  error: StandardMutationError
  task: Task
  removedNotification: NotifyTaskInvolves

  """
  the taskId sent to a user who is not on the new team so they can remove it from their client
  """
  removedTaskId: ID
}

"""The meeting phase where all team members check in one-by-one"""
type CheckInPhase implements NewMeetingPhase {
  """shortid"""
  id: ID!

  """The type of phase"""
  phaseType: NewMeetingPhaseTypeEnum
  stages: [CheckInStage!]!

  """The checkIn greeting (fun language)"""
  checkInGreeting: MeetingGreeting!

  """The checkIn question of the week (draft-js format)"""
  checkInQuestion: String!
}

"""A stage that focuses on a single team member"""
type CheckInStage implements NewMeetingStage & NewMeetingTeamMemberStage {
  """shortid"""
  id: ID!

  """The datetime the stage was completed"""
  endAt: DateTime

  """foreign key. try using meeting"""
  meetingId: ID!

  """The meeting this stage belongs to"""
  meeting: NewMeeting

  """
  true if the facilitator has completed this stage, else false. Should be boolean(endAt)
  """
  isComplete: Boolean

  """true if any meeting participant can navigate to this stage"""
  isNavigable: Boolean

  """true if the facilitator can navigate to this stage"""
  isNavigableByFacilitator: Boolean

  """The phase this stage belongs to"""
  phase: NewMeetingPhase

  """The type of the phase"""
  phaseType: NewMeetingPhaseTypeEnum

  """The datetime the stage was started"""
  startAt: DateTime

  """Number of times the facilitator has visited this stage"""
  viewCount: Int

  """foreign key. use teamMember"""
  teamMemberId: ID!

  """The team member that is the focus for this phase item"""
  teamMember: TeamMember

  """true if the team member is present for the meeting"""
  present: Boolean
}

type ClearNotificationPayload {
  error: StandardMutationError

  """The deleted notifcation"""
  notification: Notification
}

"""Coordinates used relay a location in a 2-D plane"""
type Coords2D {
  x: Float!
  y: Float!
}

"""Coordinates used relay a location in a 2-D plane"""
input Coords2DInput {
  x: Float!
  y: Float!
}

input CreateAgendaItemInput {
  """The content of the agenda item"""
  content: String!
  teamId: ID!

  """The team member ID of the person creating the agenda item"""
  teamMemberId: ID!

  """The sort order of the agenda item in the list"""
  sortOrder: Float
}

type CreateGitHubIssuePayload {
  error: StandardMutationError
  task: Task
}

type CreateImposterTokenPayload {
  error: StandardMutationError

  """The new JWT"""
  authToken: ID

  """The user you have assumed"""
  user: User
}

type CreatePicturePutUrlPayload {
  error: StandardMutationError
  url: URL
}

type CreateReflectionGroupPayload {
  error: StandardMutationError
  meeting: NewMeeting
  reflectionGroup: RetroReflectionGroup
}

input CreateReflectionInput {
  """A stringified draft-js document containing thoughts"""
  content: String

  """The phase item the reflection belongs to"""
  retroPhaseItemId: ID!
  sortOrder: Float!
}

type CreateReflectionPayload {
  error: StandardMutationError
  meeting: NewMeeting
  reflection: RetroReflection

  """The group automatically created for the reflection"""
  reflectionGroup: RetroReflectionGroup

  """The stages that were unlocked by navigating"""
  unlockedStages: [NewMeetingStage!]
}

input CreateTaskInput {
  """foreign key for AgendaItem"""
  agendaId: ID
  content: String

  """foreign key for the meeting this was created in"""
  meetingId: ID

  """foreign key for the reflection group this was created from"""
  reflectionGroupId: ID
  sortOrder: Float
  status: TaskStatusEnum

  """teamId, the team the task is on"""
  teamId: ID

  """userId, the owner of the task"""
  userId: ID
}

type CreateTaskPayload {
  error: StandardMutationError
  task: Task
  involvementNotification: NotifyTaskInvolves
}

type CreateUserPicturePutUrlPayload {
  error: StandardMutationError
  url: URL
  pngUrl: URL
}

"""A credit card"""
type CreditCard {
  """The brand of the credit card, as provided by skype"""
  brand: String

  """The MM/YY string of the expiration date"""
  expiry: String

  """The last 4 digits of a credit card"""
  last4: Int
}

interface CustomPhaseItem {
  """shortid"""
  id: ID!
  createdAt: DateTime!

  """The type of phase item"""
  phaseItemType: CustomPhaseItemTypeEnum

  """true if the phase item is currently used by the team, else false"""
  isActive: Boolean

  """foreign key. use the team field"""
  teamId: ID!

  """The team that owns this customPhaseItem"""
  team: Team
  updatedAt: DateTime!
}

"""The type of phase item"""
enum CustomPhaseItemTypeEnum {
  retroPhaseItem
}

scalar DateTime

type DeleteTaskPayload {
  error: StandardMutationError

  """The task that was deleted"""
  task: Task

  """The notification stating that the viewer was mentioned or assigned"""
  involvementNotification: NotifyTaskInvolves
}

type DisconnectSocketPayload {
  """The user that disconnected"""
  user: User
}

"""
The meeting phase where all team members discuss the topics with the most votes
"""
type DiscussPhase implements NewMeetingPhase {
  """shortid"""
  id: ID!

  """The type of phase"""
  phaseType: NewMeetingPhaseTypeEnum
  stages: [RetroDiscussStage!]!
}

type DismissNewFeaturePayload {
  error: StandardMutationError
}

type DismissSuggestedActionPayload {
  error: StandardMutationError

  """The user that dismissed the action"""
  user: User

  """The id of the removed suggested action"""
  removedSuggestedActionId: ID
}

type DowngradeToPersonalPayload {
  error: StandardMutationError

  """The new Personal Org"""
  organization: Organization

  """The updated teams under the org"""
  teams: [Team]
}

"""Info associated with a current drag"""
type DragContext {
  id: ID

  """The userId of the person currently dragging the reflection"""
  dragUserId: ID

  """The user that is currently dragging the reflection"""
  dragUser: User

  """The coordinates necessary to simulate a drag for a subscribing user"""
  dragCoords: Coords2D
}

type DragDiscussionTopicPayload {
  error: StandardMutationError
  meeting: NewMeeting
  stage: RetroDiscussStage
}

"""The possible places a reflection can be dropped"""
enum DragReflectionDropTargetTypeEnum {
  REFLECTION_GROUP
  REFLECTION_GRID
}

type EditReflectionPayload {
  error: StandardMutationError
  phaseItemId: ID

  """
  The socketId of the client editing the card (uses socketId to maintain anonymity)
  """
  editorId: ID

  """true if the reflection is being edited, else false """
  isEditing: Boolean
}

type EditTaskPayload {
  error: StandardMutationError
  task: Task
  editor: User

  """true if the editor is editing, false if they stopped editing"""
  isEditing: Boolean
}

scalar Email

type EndDraggingReflectionPayload {
  error: StandardMutationError
  dragId: ID

  """the type of item the reflection was dropped on"""
  dropTargetType: DragReflectionDropTargetTypeEnum

  """
  The ID that the dragged item was dropped on, if dropTargetType is not specific enough
  """
  dropTargetId: ID
  meeting: RetrospectiveMeeting
  meetingId: ID
  reflection: RetroReflection
  reflectionGroupId: ID
  reflectionId: ID

  """foreign key to get user"""
  userId: ID

  """
  The group encapsulating the new reflection. A new one was created if one was not provided.
  """
  reflectionGroup: RetroReflectionGroup

  """The old group the reflection was in"""
  oldReflectionGroup: RetroReflectionGroup
}

type EndMeetingPayload {
  error: StandardMutationError
  team: Team

  """The list of tasks that were archived during the meeting"""
  archivedTasks: [Task]
  meeting: Meeting

  """The ID of the suggestion to try an action meeting, if tried"""
  removedSuggestedActionId: ID
}

type EndNewMeetingPayload {
  error: StandardMutationError

  """true if the meeting was killed (ended before reaching last stage)"""
  isKill: Boolean
  team: Team
  meeting: NewMeeting

  """The ID of the suggestion to try a retro meeting, if tried"""
  removedSuggestedActionId: ID
}

"""An all-purpose meeting phase with no extra state"""
type GenericMeetingPhase implements NewMeetingPhase {
  """shortid"""
  id: ID!

  """The type of phase"""
  phaseType: NewMeetingPhaseTypeEnum
  stages: [GenericMeetingStage!]!
}

"""
A stage of a meeting that has no extra state. Only used for single-stage phases
"""
type GenericMeetingStage implements NewMeetingStage {
  """shortid"""
  id: ID!

  """The datetime the stage was completed"""
  endAt: DateTime

  """foreign key. try using meeting"""
  meetingId: ID!

  """The meeting this stage belongs to"""
  meeting: NewMeeting

  """
  true if the facilitator has completed this stage, else false. Should be boolean(endAt)
  """
  isComplete: Boolean

  """true if any meeting participant can navigate to this stage"""
  isNavigable: Boolean

  """true if the facilitator can navigate to this stage"""
  isNavigableByFacilitator: Boolean

  """The phase this stage belongs to"""
  phase: NewMeetingPhase

  """The type of the phase"""
  phaseType: NewMeetingPhaseTypeEnum

  """The datetime the stage was started"""
  startAt: DateTime

  """Number of times the facilitator has visited this stage"""
  viewCount: Int
}

"""An integration that connects github issues & PRs to Parabol tasks"""
type GitHubIntegration {
  """The ID of an object"""
  id: ID!

  """The parabol userId of the admin for this repo (usually the creator)"""
  adminUserId: ID!

  """The datetime the integration was created"""
  createdAt: DateTime!

  """The name of the repo. Follows format of OWNER/NAME"""
  nameWithOwner: String

  """defaults to true. true if this is used"""
  isActive: Boolean

  """*The team that is linked to this integration"""
  teamId: ID!

  """The users that can CRUD this integration"""
  teamMembers: [TeamMember!]!

  """The datetime the integration was updated"""
  updatedAt: DateTime!

  """
  *The userIds connected to the repo so they can CRUD things under their own name
  """
  userIds: [ID]
}

type GitHubMemberRemovedPayload {
  leaveIntegration: [LeaveIntegrationPayload]
}

"""The details associated with a task integrated with GitHub"""
type GitHubTask implements TaskIntegration {
  id: ID!
  service: TaskServiceEnum!
  nameWithOwner: String
  issueNumber: Int
}

type GoogleAnalyzedEntity {
  """
  The lemma (dictionary entry) of the entity name. Fancy way of saying the singular form of the name, if plural.
  """
  lemma: String!

  """
  The name of the entity. Usually 1 or 2 words. Always a noun, sometimes a proper noun.
  """
  name: String!

  """
  The salience of the entity in the provided text. The salience of all entities always sums to 1
  """
  salience: Float!
}

type GroupPhaseCompletePayload {
  """the current meeting"""
  meeting: RetrospectiveMeeting!

  """a list of updated reflection groups"""
  reflectionGroups: [RetroReflectionGroup]
}

input ImageMetadataInput {
  """user-supplied MIME content type"""
  contentType: String!

  """user-supplied file size"""
  contentLength: Int!
}

type InactivateUserPayload {
  error: StandardMutationError

  """The user that has been inactivated"""
  user: User
}

"""The list of services for integrations"""
enum IntegrationServiceEnum {
  GitHubIntegration
  SlackIntegration
  atlassian
}

union IntegrationSubscriptionPayload = AddProviderPayload | RemoveProviderPayload

type InviteToTeamPayload {
  error: StandardMutationError

  """The team the inviter is inviting the invitee to"""
  team: Team

  """A list of email addresses the invitations were sent to"""
  invitees: [Email!]

  """
  the notification ID if this payload is sent to a subscriber, else null
  """
  teamInvitationNotificationId: ID

  """The notification sent to the invitee if they are a parabol user"""
  teamInvitationNotification: NotificationTeamInvitation

  """the `invite your team` suggested action that was removed, if any"""
  removedSuggestedActionId: ID
}

"""A monthly billing invoice for an organization"""
type Invoice {
  """A shortid for the invoice"""
  id: ID

  """
  The amount the card will be charged (total + startingBalance with a min value of 0)
  """
  amountDue: Float

  """The datetime the invoice was first generated"""
  createdAt: DateTime

  """The total amount for the invoice (in USD)"""
  total: Float

  """The emails the invoice was sent to"""
  billingLeaderEmails: [Email]

  """the card used to pay the invoice"""
  creditCard: CreditCard

  """The timestamp for the end of the billing cycle"""
  endAt: DateTime

  """The date the invoice was created"""
  invoiceDate: DateTime

  """An invoice line item for previous month adjustments"""
  lines: [InvoiceLineItem!]

  """The details that comprise the charges for next month"""
  nextMonthCharges: InvoiceChargeNextMonth

  """*The organization id to charge"""
  orgId: ID

  """The persisted name of the org as it was when invoiced"""
  orgName: String

  """the datetime the invoice was successfully paid"""
  paidAt: DateTime

  """The picture of the organization"""
  picture: URL

  """The timestamp for the beginning of the billing cycle"""
  startAt: DateTime

  """The balance on the customer account (in cents)"""
  startingBalance: Float

  """
  the status of the invoice. starts as pending, moves to paid or unpaid depending on if the payment succeeded
  """
  status: InvoiceStatusEnum
}

"""A single line item for the charges for next month"""
type InvoiceChargeNextMonth {
  """The amount for the line item (in USD)"""
  amount: Float!

  """The datetime the next period will end"""
  nextPeriodEnd: DateTime

  """
  The total number of days that all org users have been inactive during the billing cycle
  """
  quantity: Int

  """The per-seat monthly price of the subscription (in dollars)"""
  unitPrice: Float
}

"""A connection to a list of items."""
type InvoiceConnection {
  """Page info with cursors coerced to ISO8601 dates"""
  pageInfo: PageInfoDateCursor

  """A list of edges."""
  edges: [InvoiceEdge!]!
}

"""An edge in a connection."""
type InvoiceEdge {
  """The item at the end of the edge"""
  node: Invoice!
  cursor: DateTime
}

"""A single line item charge on the invoice"""
type InvoiceLineItem {
  """The unique line item id"""
  id: ID!

  """The amount for the line item (in USD)"""
  amount: Float!

  """
  A description of the charge. Only present if we have no idea what the charge is
  """
  description: String

  """
  Array of user activity line items that roll up to total activity (add/leave/pause/unpause)
  """
  details: [InvoiceLineItemDetails!]

  """
  The total number of days that all org users have been inactive during the billing cycle
  """
  quantity: Int

  """The line item type for a monthly billing invoice"""
  type: InvoiceLineItemEnum
}

"""The per-user-action line item details,"""
type InvoiceLineItemDetails {
  """The unique detailed line item id"""
  id: ID!

  """The amount for the line item (in USD)"""
  amount: Float!

  """The email affected by this line item change"""
  email: Email

  """
  End of the event. Only present if a pause action gets matched up with an unpause action
  """
  endAt: DateTime

  """The parent line item id"""
  parentId: ID!

  """The timestamp for the beginning of the period of no charge"""
  startAt: DateTime
}

"""A big picture line item"""
enum InvoiceLineItemEnum {
  ADDED_USERS
  INACTIVITY_ADJUSTMENTS
  OTHER_ADJUSTMENTS
  REMOVED_USERS
}

"""The payment status of the invoice"""
enum InvoiceStatusEnum {
  PENDING
  PAID
  FAILED
  UPCOMING
}

"""A project fetched from Jira in real time"""
type JiraRemoteAvatarUrls {
  x48: ID!
  x24: ID!
  x16: ID!
  x32: ID!
}

"""A project fetched from Jira in real time"""
type JiraRemoteProject {
  self: ID!
  id: ID!
  key: String!
  name: String!
  avatarUrls: JiraRemoteAvatarUrls!
  projectCategory: JiraRemoteProjectCategory!
  simplified: Boolean!
  style: String!
}

"""A project category fetched from a JiraRemoteProject"""
type JiraRemoteProjectCategory {
  self: String!
  id: String!
  name: String!
  description: String!
}

type JoinIntegrationPayload {
  error: StandardMutationError

  """The globalId of the integration with a removed member"""
  globalId: ID!
  teamMember: TeamMember!
}

type KillMeetingPayload {
  error: StandardMutationError
  team: Team
}

type LeaveIntegrationPayload {
  error: StandardMutationError

  """The globalId of the integration with a removed member"""
  globalId: ID!

  """
  The global userId of the viewer that left. if null, remove the entire integration
  """
  userId: ID

  """
  The list of tasks removed triggered by a removed repo if this was the last viewer on the repo
  """
  archivedTaskIds: [ID]
}

type LoginPayload {
  error: StandardMutationError

  """The user that just logged in"""
  user: User

  """The new JWT"""
  authToken: ID
}

"""A team meeting history for all previous meetings"""
type Meeting {
  """The unique meeting id. shortid."""
  id: ID!

  """The number of agenda items completed during the meeting"""
  agendaItemsCompleted: Int

  """The timestamp the meeting was created"""
  createdAt: DateTime

  """The timestamp the meeting officially ended"""
  endedAt: DateTime

  """The teamMemberId of the person who ended the meeting"""
  facilitator: ID
  invitees: [MeetingInvitee]

  """The auto-incrementing meeting number for the team"""
  meetingNumber: Int!

  """A list of immutable tasks, as they were created in the meeting"""
  tasks: [MeetingTask]

  """the number of tasks generated in the meeting"""
  taskCount: Int!

  """
  The start time used to create the diff (all taskDiffs occurred between this time and the endTime
  """
  sinceTime: DateTime

  """The happy introductory clause to the summary"""
  successExpression: String

  """The happy body statement for the summary"""
  successStatement: String

  """The time the meeting summary was emailed to the team"""
  summarySentAt: DateTime

  """The team associated with this meeting"""
  teamId: ID!

  """The name as it was when the meeting occurred"""
  teamName: String

  """All the team members associated who can join this team"""
  teamMembers: [TeamMember]
}

type MeetingCheckInPayload {
  error: StandardMutationError
  teamMember: TeamMember
}

type MeetingGreeting {
  """The foreign-language greeting"""
  content: String!

  """The source language for the greeting"""
  language: String!
}

"""The user invited to the meeting"""
type MeetingInvitee {
  """The teamMemberId of the user invited to the meeting"""
  id: ID

  """true if the invitee was present in the meeting"""
  present: Boolean

  """A list of immutable tasks, as they were created in the meeting"""
  tasks: [MeetingTask]

  """url of user’s profile picture"""
  picture: URL

  """The name, as confirmed by the user"""
  preferredName: String

  """All of the fields from the team member table"""
  membership: TeamMember
}

"""All the user details for a specific meeting"""
interface MeetingMember {
  """A composite of userId::meetingId"""
  id: ID!

  """true if present, false if absent, else null"""
  isCheckedIn: Boolean
  meetingId: ID
  meetingType: MeetingTypeEnum!
  teamId: ID
  user: User
  userId: ID

  """The last time a meeting was updated (stage completed, finished, etc)"""
  updatedAt: DateTime
}

"""The task that was created in a meeting"""
type MeetingTask {
  """The unique action id, meetingId::taskId"""
  id: ID!

  """
  The stringified Draft-js raw description of the action created during the meeting
  """
  content: String!

  """The description of the action created during the meeting"""
  status: TaskStatusEnum

  """The tags associated with the task"""
  tags: [String]

  """
  The id of the team member the action was assigned to during the meeting
  """
  assigneeId: ID!
}

"""The phases of an action meeting"""
enum MeetingTypeEnum {
  action
  retrospective
}

type MoveMeetingPayload {
  error: StandardMutationError
  team: Team

  """The agendaItem completed, if any"""
  completedAgendaItem: AgendaItem
}

type MoveReflectTemplatePromptPayload {
  error: StandardMutationError
  prompt: RetroPhaseItem
}

type Mutation {
  """Redeem an invitation token for a logged in user"""
  acceptTeamInvitation(
    """The 48-byte hex encoded invitation token"""
    invitationToken: ID

    """the notification clicked to accept, if any"""
    notificationId: ID
  ): AcceptTeamInvitationPayload!
  addAtlassianAuth(code: ID!, teamId: ID!): AddAtlassianAuthPayload!

  """Create a new agenda item"""
  addAgendaItem(
    """The new task including an id, teamMemberId, and content"""
    newAgendaItem: CreateAgendaItemInput!
  ): AddAgendaItemPayload

  """Give someone advanced features in a flag"""
  addFeatureFlag(
    """
    the complete or partial email of the person to whom you are giving advanced features. 
          Matches via a regex to support entire domains
    """
    email: String!

    """the flag that you want to give to the user"""
    flag: UserFlagEnum!
  ): AddFeatureFlagPayload
  addGitHubRepo(teamId: ID!, nameWithOwner: String!): AddGitHubRepoPayload!

  """Create a new team and add the first team member"""
  addOrg(
    """The new team object with exactly 1 team member"""
    newTeam: NewTeamInput!

    """The name of the new team"""
    orgName: String
  ): AddOrgPayload
  addProvider(code: ID!, service: IntegrationServiceEnum!, teamId: ID!): AddProviderPayload!
  addSlackChannel(input: AddSlackChannelInput!): AddSlackChannelPayload!

  """Create a new team and add the first team member"""
  addTeam(
    """The new team object"""
    newTeam: NewTeamInput!
  ): AddTeamPayload
  archiveTeam(
    """The teamId to archive (or delete, if team is unused)"""
    teamId: ID!
  ): ArchiveTeamPayload

  """Automatically group reflections"""
  autoGroupReflections(
    meetingId: ID!

    """
    A number from 0 to 1 to determine how tightly to pack the groups. Higher means fewer groups
    """
    groupingThreshold: Float!
  ): AutoGroupReflectionsPayload

  """Change the team a task is associated with"""
  changeTaskTeam(
    """The task to change"""
    taskId: ID!

    """The new team to assign the task to"""
    teamId: ID!
  ): ChangeTaskTeamPayload

  """Remove a notification by ID"""
  clearNotification(
    """The id of the notification to remove"""
    notificationId: ID!
  ): ClearNotificationPayload

  """a server-side mutation called when a client connects"""
  connectSocket: User

  """for troubleshooting by admins, create a JWT for a given userId"""
  createImposterToken(
    """The target userId to impersonate"""
    userId: ID!
  ): CreateImposterTokenPayload
  createGitHubIssue(
    """The id of the task to convert to a GH issue"""
    taskId: ID!

    """The owner/repo string"""
    nameWithOwner: String!
  ): CreateGitHubIssuePayload

  """Create a PUT URL on the CDN for an organization’s profile picture"""
  createOrgPicturePutUrl(
    """user-supplied MIME content type"""
    contentType: String!

    """user-supplied file size"""
    contentLength: Int!

    """The organization id to update"""
    orgId: ID!
  ): CreatePicturePutUrlPayload

  """Create a new reflection"""
  createReflection(input: CreateReflectionInput!): CreateReflectionPayload

  """Create a new reflection group"""
  createReflectionGroup(
    meetingId: ID!

    """
    An array of 1 or 2 reflections that make up the group. The first card in the array will be used to determine sort order
    """
    reflectionIds: [ID!]!
  ): CreateReflectionGroupPayload

  """Create a new task, triggering a CreateCard for other viewers"""
  createTask(
    """The new task including an id, status, and type, and teamMemberId"""
    newTask: CreateTaskInput!

    """The part of the site where the creation occurred"""
    area: AreaEnum
  ): CreateTaskPayload

  """
  Create a PUT URL on the CDN for the currently authenticated user’s profile picture
  """
  createUserPicturePutUrl(
    """user supplied image metadata"""
    image: ImageMetadataInput!

    """a png version of the above image"""
    pngVersion: ImageMetadataInput
  ): CreateUserPicturePutUrlPayload

  """Delete (not archive!) a task"""
  deleteTask(
    """The taskId to delete"""
    taskId: ID!
  ): DeleteTaskPayload

  """a server-side mutation called when a client disconnects"""
  disconnectSocket: DisconnectSocketPayload

  """Redeem an invitation token for a logged in user"""
  dismissNewFeature: DismissNewFeaturePayload!

  """Dismiss a suggested action"""
  dismissSuggestedAction(
    """The id of the suggested action to dismiss"""
    suggestedActionId: ID!
  ): DismissSuggestedActionPayload!

  """Downgrade a paid account to the personal service"""
  downgradeToPersonal(
    """the org requesting the upgrade"""
    orgId: ID!
  ): DowngradeToPersonalPayload

  """Changes the priority of the discussion topics"""
  dragDiscussionTopic(meetingId: ID!, stageId: ID!, sortOrder: Float!): DragDiscussionTopicPayload

  """Broadcast that the viewer stopped dragging a reflection"""
  endDraggingReflection(
    reflectionId: ID!

    """
    if it was a drop (isDragging = false), the type of item it was dropped on. null if there was no valid drop target
    """
    dropTargetType: DragReflectionDropTargetTypeEnum

    """
    if dropTargetType could refer to more than 1 component, this ID defines which one
    """
    dropTargetId: ID

    """the ID of the drag to connect to the start drag event"""
    dragId: ID
  ): EndDraggingReflectionPayload

  """Changes the editing state of a user for a phase item"""
  editReflection(
    phaseItemId: ID!

    """Whether a phaseItem is being edited or not"""
    isEditing: Boolean!
  ): EditReflectionPayload

  """Announce to everyone that you are editing a task"""
  editTask(
    """The task id that is being edited"""
    taskId: ID!

    """true if the editing is starting, false if it is stopping"""
    isEditing: Boolean!
  ): EditTaskPayload

  """Finish a meeting and go to the summary"""
  endMeeting(
    """The team that will be having the meeting"""
    teamId: ID!
  ): EndMeetingPayload

  """Receive a webhook from github saying an assignee was added"""
  githubAddAssignee(
    """The github issue id"""
    integrationId: ID!

    """The github login for the new assignee"""
    assigneeLogin: ID!

    """The repo name and owner"""
    nameWithOwner: ID!
  ): Boolean

  """Receive a webhook from github saying an org member was added"""
  githubAddMember(
    """The github login"""
    userName: ID!

    """The github org login"""
    orgName: ID!
  ): Boolean

  """Receive a webhook from github saying an org member was removed"""
  githubRemoveMember(
    """The github login"""
    userName: ID!

    """The github org login"""
    orgName: ID!
  ): Boolean

  """pauses the subscription for a single user"""
  inactivateUser(
    """the user to pause"""
    userId: ID!
  ): InactivateUserPayload

  """Send a team invitation to an email address"""
  inviteToTeam(
    """The id of the inviting team"""
    teamId: ID!
    invitees: [Email!]!
  ): InviteToTeamPayload!

  """Add a user to an integration"""
  joinIntegration(
    """The global id of the integration to join"""
    globalId: ID!
  ): JoinIntegrationPayload!

  """Finish a meeting abruptly"""
  killMeeting(
    """The team that will be having the meeting"""
    teamId: ID!
  ): KillMeetingPayload

  """Finish a new meeting abruptly"""
  endNewMeeting(
    """The meeting to end"""
    meetingId: ID!
  ): EndNewMeetingPayload

  """Remove yourself from an integration"""
  leaveIntegration(
    """the id of the integration to remove"""
    globalId: ID!
  ): LeaveIntegrationPayload!

  """Check a member in as present or absent"""
  meetingCheckIn(
    """The global teamMemberId of the person who is being checked in"""
    teamMemberId: ID!

    """true if the member is present, false if absent, null if undecided"""
    isCheckedIn: Boolean
  ): MeetingCheckInPayload

  """
  Update the facilitator. If this is new territory for the meetingPhaseItem, advance that, too.
  """
  moveMeeting(
    """The teamId to make sure the socket calling has permission"""
    teamId: ID!

    """The desired phase for the meeting"""
    nextPhase: ActionMeetingPhaseEnum

    """The item within the phase to set the meeting to"""
    nextPhaseItem: Int

    """If true, execute the mutation without regard for meeting flow"""
    force: Boolean
  ): MoveMeetingPayload

  """
  Move a team to a different org. Requires billing leader rights on both orgs!
  """
  moveTeamToOrg(
    """The teamId that you want to move"""
    teamId: ID!

    """The ID of the organization you want to move the team to"""
    orgId: ID!
  ): String

  """
  update a meeting by marking an item complete and setting the facilitator location
  """
  navigateMeeting(
    """The stage that the facilitator would like to mark as complete"""
    completedStageId: ID

    """The stage where the facilitator is"""
    facilitatorStageId: ID

    """The meeting ID"""
    meetingId: ID!
  ): NavigateMeetingPayload!

  """Check a member in as present or absent"""
  newMeetingCheckIn(
    """The id of the user being marked present or absent"""
    userId: ID!

    """the meeting currently in progress"""
    meetingId: ID!

    """true if the member is present, false if absent, null if undecided"""
    isCheckedIn: Boolean
  ): NewMeetingCheckInPayload

  """Change a facilitator while the meeting is in progress"""
  promoteFacilitator(
    """teamMemberId of the old facilitator, if they disconnected"""
    disconnectedFacilitatorId: ID

    """teamMemberId of the new facilitator for this meeting"""
    facilitatorId: ID!
  ): PromoteFacilitatorPayload

  """Change a facilitator while the meeting is in progress"""
  promoteNewMeetingFacilitator(
    """userId of the new facilitator for this meeting"""
    facilitatorUserId: ID!
    meetingId: ID!
  ): PromoteNewMeetingFacilitatorPayload

  """Promote another team member to be the leader"""
  promoteToTeamLead(
    """the new team member that will be the leader"""
    teamMemberId: ID!
  ): PromoteToTeamLeadPayload

  """Remove an agenda item"""
  removeAgendaItem(
    """The agenda item unique id"""
    agendaItemId: ID!
  ): RemoveAgendaItemPayload

  """Disconnect a team member from atlassian"""
  removeAtlassianAuth(
    """the teamId to disconnect from the token"""
    teamId: ID!
  ): RemoveAtlassianAuthPayload!

  """Disconnect a team from a Provider token"""
  removeProvider(
    """The relay id of the service to remove"""
    providerId: ID!

    """the teamId to disconnect from the token"""
    teamId: ID!
  ): RemoveProviderPayload!

  """Remove a slack channel integration from a team"""
  removeSlackChannel(slackGlobalId: ID!): RemoveSlackChannelPayload!

  """Remove a github repo integration from a team"""
  removeGitHubRepo(githubIntegrationId: ID!): RemoveGitHubRepoPayload!

  """Remove a user from an org"""
  removeOrgUser(
    """the user to remove"""
    userId: ID!

    """the org that does not want them anymore"""
    orgId: ID!
  ): RemoveOrgUserPayload

  """Remove a reflection"""
  removeReflection(reflectionId: ID!): RemoveReflectionPayload

  """Remove a team member from the team"""
  removeTeamMember(
    """The teamMemberId of the person who is being removed"""
    teamMemberId: ID!
  ): RemoveTeamMemberPayload

  """Request to become the facilitator in a meeting"""
  requestFacilitator(teamId: ID!): RequestFacilitatorPayload

  """track an event in segment, like when errors are hit"""
  segmentEventTrack(event: String!, options: SegmentEventTrackOptions): Boolean

  """Set the selected template for the upcoming retro meeting"""
  selectRetroTemplate(selectedTemplateId: ID!, teamId: ID!): SelectRetroTemplatePayload

  """Set the role of a user"""
  setOrgUserRole(
    """The org to affect"""
    orgId: ID!

    """the user who is receiving a role change"""
    userId: ID!

    """the user’s new role"""
    role: String
  ): SetOrgUserRolePayload

  """Focus (or unfocus) a phase item"""
  setPhaseFocus(
    meetingId: ID!

    """The currently focused phase item"""
    focusedPhaseItemId: ID
  ): SetPhaseFocusPayload

  """Broadcast that the viewer started dragging a reflection"""
  startDraggingReflection(reflectionId: ID!, initialCoords: Coords2DInput!): StartDraggingReflectionPayload

  """Start a meeting from the lobby"""
  startMeeting(
    """The team starting the meeting"""
    teamId: ID!
  ): StartMeetingPayload

  """Start a new meeting"""
  startNewMeeting(
    """The team starting the meeting"""
    teamId: ID!

    """The base type of the meeting (action, retro, etc)"""
    meetingType: MeetingTypeEnum!
  ): StartNewMeetingPayload

  """When stripe tells us an invoice is ready, create a pretty version"""
  stripeCreateInvoice(
    """The stripe invoice ID"""
    invoiceId: ID!
  ): Boolean

  """When stripe tells us an invoice payment failed, update it in our DB"""
  stripeFailPayment(
    """The stripe invoice ID"""
    invoiceId: ID!
  ): StripeFailPaymentPayload

  """
  When stripe tells us an invoice payment was successful, update it in our DB
  """
  stripeSucceedPayment(
    """The stripe invoice ID"""
    invoiceId: ID!
  ): Boolean

  """
  When stripe tells us a credit card was updated, update the details in our own DB
  """
  stripeUpdateCreditCard(
    """The stripe customer ID, or stripeId"""
    customerId: ID!
  ): Boolean

  """When a new invoiceitem is sent from stripe, tag it with metadata"""
  stripeUpdateInvoiceItem(
    """The stripe invoice ID"""
    invoiceItemId: ID!
  ): Boolean

  """Show/hide the agenda list"""
  toggleAgendaList(
    """the team to hide the agenda for"""
    teamId: ID!
  ): TeamMember

  """Update an agenda item"""
  updateAgendaItem(
    """The updated item including an id, content, status, sortOrder"""
    updatedAgendaItem: UpdateAgendaItemInput!
  ): UpdateAgendaItemPayload

  """Update an existing credit card on file"""
  updateCreditCard(
    """the org requesting the changed billing"""
    orgId: ID!

    """The token that came back from stripe"""
    stripeToken: ID!
  ): UpdateCreditCardPayload

  """Update an with a change in name, avatar"""
  updateOrg(
    """the updated org including the id, and at least one other field"""
    updatedOrg: UpdateOrgInput!
  ): UpdateOrgPayload!

  """Update a Team's Check-in question"""
  updateCheckInQuestion(
    """ID of the Team which will have its Check-in question updated"""
    teamId: ID!

    """The Team's new Check-in question"""
    checkInQuestion: String!
  ): UpdateCheckInQuestionPayload

  """Update a Team's Check-in question in a new meeting"""
  updateNewCheckInQuestion(
    """ID of the Team which will have its Check-in question updated"""
    meetingId: ID!

    """The Team's new Check-in question"""
    checkInQuestion: String!
  ): UpdateNewCheckInQuestionPayload

  """
  all the info required to provide an accurate display-specific location of where an item is
  """
  updateDragLocation(input: UpdateDragLocationInput!): Boolean

  """Update the content of a reflection"""
  updateReflectionContent(
    reflectionId: ID!

    """A stringified draft-js document containing thoughts"""
    content: String!
  ): UpdateReflectionContentPayload

  """Update the title of a reflection group"""
  updateReflectionGroupTitle(
    reflectionGroupId: ID!

    """The new title for the group"""
    title: String!
  ): UpdateReflectionGroupTitlePayload

  """Update a task with a change in content, ownership, or status"""
  updateTask(
    """The part of the site where the creation occurred"""
    area: AreaEnum

    """the updated task including the id, and at least one other field"""
    updatedTask: UpdateTaskInput!
  ): UpdateTaskPayload

  """Set or unset the due date of a task"""
  updateTaskDueDate(
    """The task id"""
    taskId: ID!

    """the new due date. if not a valid date, it will unset the due date"""
    dueDate: DateTime
  ): UpdateTaskDueDatePayload
  updateTeamName(
    """The input object containing the teamId and any modified fields"""
    updatedTeam: UpdatedTeamInput!
  ): UpdateTeamNamePayload
  updateUserProfile(
    """
    The input object containing the user profile fields that can be changed
    """
    updatedUser: UpdateUserProfileInput!
  ): UpdateUserProfilePayload

  """Cast your vote for a reflection group"""
  voteForReflectionGroup(
    """true if the user wants to remove one of their votes"""
    isUnvote: Boolean
    reflectionGroupId: ID!
  ): VoteForReflectionGroupPayload

  """Log in, or sign up if it is a new user"""
  login(
    """The ID Token from auth0, a base64 JWT"""
    auth0Token: String!

    """true if the user is signing up without a team invitation, else false"""
    isOrganic: Boolean!

    """optional segment id created before they were a user"""
    segmentId: ID
  ): LoginPayload!

  """Upgrade an account to the paid service"""
  upgradeToPro(
    """the org requesting the upgrade"""
    orgId: ID!

    """The token that came back from stripe"""
    stripeToken: ID!
  ): UpgradeToProPayload

  """Add a new template full of prompts"""
  addReflectTemplate(teamId: ID!): AddReflectTemplatePayload

  """Add a new template full of prompts"""
  addReflectTemplatePrompt(templateId: ID!): AddReflectTemplatePromptPayload

  """Move a reflect template"""
  moveReflectTemplatePrompt(promptId: ID!, sortOrder: Float!): MoveReflectTemplatePromptPayload

  """Remove a template full of prompts"""
  removeReflectTemplate(templateId: ID!): RemoveReflectTemplatePayload

  """Remove a prompt from a template"""
  removeReflectTemplatePrompt(promptId: ID!): RemoveReflectTemplatePromptPayload

  """Rename a reflect template prompt"""
  renameReflectTemplate(templateId: ID!, name: String!): RenameReflectTemplatePayload

  """Rename a reflect template"""
  renameReflectTemplatePrompt(promptId: ID!, question: String!): RenameReflectTemplatePromptPayload
}

type NavigateMeetingPayload {
  error: StandardMutationError
  meeting: NewMeeting

  """The stage that the facilitator is now on"""
  facilitatorStage: NewMeetingStage

  """The stage that the facilitator left"""
  oldFacilitatorStage: NewMeetingStage

  """Additional details triggered by completing certain phases"""
  phaseComplete: PhaseCompletePayload

  """The stages that were unlocked by navigating"""
  unlockedStages: [NewMeetingStage!]
}

"""The latest features released by Parabol"""
type NewFeatureBroadcast {
  id: ID!

  """The description of the new features"""
  copy: String!

  """The permalink to the blog post describing the new features"""
  url: String!
}

"""A team meeting history for all previous meetings"""
interface NewMeeting {
  """The unique meeting id. shortid."""
  id: ID!

  """The timestamp the meeting was created"""
  createdAt: DateTime

  """The timestamp the meeting officially ended"""
  endedAt: DateTime

  """The location of the facilitator in the meeting"""
  facilitatorStageId: ID!

  """The userId (or anonymousId) of the most recent facilitator"""
  facilitatorUserId: ID!

  """The facilitator user"""
  facilitator: User!

  """The team members that were active during the time of the meeting"""
  meetingMembers: [MeetingMember]

  """The auto-incrementing meeting number for the team"""
  meetingNumber: Int!
  meetingType: MeetingTypeEnum!

  """
  The phases the meeting will go through, including all phase-specific state
  """
  phases: [NewMeetingPhase!]!

  """The time the meeting summary was emailed to the team"""
  summarySentAt: DateTime

  """foreign key for team"""
  teamId: ID!

  """The team that ran the meeting"""
  team: Team!

  """The last time a meeting was updated (stage completed, finished, etc)"""
  updatedAt: DateTime

  """The meeting member of the viewer"""
  viewerMeetingMember: MeetingMember!
}

type NewMeetingCheckInPayload {
  error: StandardMutationError
  meetingMember: MeetingMember
  meeting: NewMeeting
}

interface NewMeetingPhase {
  """shortid"""
  id: ID!

  """The type of phase"""
  phaseType: NewMeetingPhaseTypeEnum
  stages: [NewMeetingStage!]!
}

"""The phase of the meeting"""
enum NewMeetingPhaseTypeEnum {
  checkin
  updates
  firstcall
  agendaitems
  lastcall
  reflect
  group
  vote
  discuss
}

"""
An instance of a meeting phase item. On the client, this usually represents a single view
"""
interface NewMeetingStage {
  """shortid"""
  id: ID!

  """The datetime the stage was completed"""
  endAt: DateTime

  """foreign key. try using meeting"""
  meetingId: ID!

  """The meeting this stage belongs to"""
  meeting: NewMeeting

  """
  true if the facilitator has completed this stage, else false. Should be boolean(endAt)
  """
  isComplete: Boolean

  """true if any meeting participant can navigate to this stage"""
  isNavigable: Boolean

  """true if the facilitator can navigate to this stage"""
  isNavigableByFacilitator: Boolean

  """The phase this stage belongs to"""
  phase: NewMeetingPhase

  """The type of the phase"""
  phaseType: NewMeetingPhaseTypeEnum

  """The datetime the stage was started"""
  startAt: DateTime

  """Number of times the facilitator has visited this stage"""
  viewCount: Int
}

"""
An instance of a meeting phase item. On the client, this usually represents a single view
"""
interface NewMeetingTeamMemberStage {
  """foreign key. use teamMember"""
  teamMemberId: ID!

  """The team member that is the focus for this phase item"""
  teamMember: TeamMember
}

input NewTeamInput {
  """The name of the team"""
  name: String

  """The unique orginization ID that pays for the team"""
  orgId: ID
}

interface Notification {
  """A shortid for the notification"""
  id: ID!

  """true if the notification has been archived, else false (or null)"""
  isArchived: Boolean

  """
  *The unique organization ID for this notification. Can be blank for targeted notifications
  """
  orgId: ID

  """The datetime to activate the notification & send it to the client"""
  startAt: DateTime
  type: NotificationEnum

  """*The userId that should see this notification"""
  userIds: [ID!]
}

"""A connection to a list of items."""
type NotificationConnection {
  """Page info with cursors coerced to ISO8601 dates"""
  pageInfo: PageInfoDateCursor

  """A list of edges."""
  edges: [NotificationEdge!]!
}

"""An edge in a connection."""
type NotificationEdge {
  """The item at the end of the edge"""
  node: Notification!
  cursor: DateTime
}

"""The kind of notification"""
enum NotificationEnum {
  FACILITATOR_DISCONNECTED
  KICKED_OUT
  PAYMENT_REJECTED
  TASK_INVOLVES
  TEAM_INVITATION
  TEAM_ARCHIVED
  VERSION_INFO
  PROMOTE_TO_BILLING_LEADER
}

union NotificationSubscriptionPayload = AcceptTeamInvitationPayload | AddFeatureFlagPayload | AddNewFeaturePayload | AddOrgPayload | AddTeamPayload | ClearNotificationPayload | CreateTaskPayload | DeleteTaskPayload | DisconnectSocketPayload | EndMeetingPayload | EndNewMeetingPayload | InviteToTeamPayload | RemoveOrgUserPayload | StripeFailPaymentPayload | User | UpdateUserProfilePayload

"""A notification sent to a user that was invited to a new team"""
type NotificationTeamInvitation implements Notification & TeamNotification {
  """FK"""
  teamId: ID!

  """FK"""
  invitationId: ID!

  """The invitation that triggered this notification"""
  invitation: TeamInvitation!
  team: Team!

  """A shortid for the notification"""
  id: ID!

  """true if the notification has been archived, else false (or null)"""
  isArchived: Boolean

  """
  *The unique organization ID for this notification. Can be blank for targeted notifications
  """
  orgId: ID

  """The datetime to activate the notification & send it to the client"""
  startAt: DateTime
  type: NotificationEnum

  """*The userId that should see this notification"""
  userIds: [ID!]
}

"""A notification sent to someone who was just kicked off a team"""
type NotifyKickedOut implements Notification & TeamRemovedNotification {
  """A shortid for the notification"""
  id: ID!

  """true if the notification has been archived, else false (or null)"""
  isArchived: Boolean

  """
  *The unique organization ID for this notification. Can be blank for targeted notifications
  """
  orgId: ID

  """The datetime to activate the notification & send it to the client"""
  startAt: DateTime
  type: NotificationEnum

  """*The userId that should see this notification"""
  userIds: [ID!]

  """true if kicked out, false if leaving by choice"""
  isKickout: Boolean

  """The name of the team the user is joining"""
  teamName: String!

  """The teamId the user was kicked out of"""
  teamId: ID!

  """The team the task is on"""
  team: Team!
}

"""A notification sent to a user when their payment has been rejected"""
type NotifyPaymentRejected implements Notification & OrganizationNotification {
  organization: Organization

  """A shortid for the notification"""
  id: ID!

  """true if the notification has been archived, else false (or null)"""
  isArchived: Boolean

  """
  *The unique organization ID for this notification. Can be blank for targeted notifications
  """
  orgId: ID

  """The datetime to activate the notification & send it to the client"""
  startAt: DateTime
  type: NotificationEnum

  """*The userId that should see this notification"""
  userIds: [ID!]
}

"""
A notification alerting the user that they have been promoted (to team or org leader)
"""
type NotifyPromoteToOrgLeader implements Notification & OrganizationNotification {
  organization: Organization

  """A shortid for the notification"""
  id: ID!

  """true if the notification has been archived, else false (or null)"""
  isArchived: Boolean

  """
  *The unique organization ID for this notification. Can be blank for targeted notifications
  """
  orgId: ID

  """The datetime to activate the notification & send it to the client"""
  startAt: DateTime
  type: NotificationEnum

  """*The userId that should see this notification"""
  userIds: [ID!]
}

"""A notification sent to someone who was just added to a team"""
type NotifyTaskInvolves implements Notification & TeamNotification {
  """A shortid for the notification"""
  id: ID!

  """true if the notification has been archived, else false (or null)"""
  isArchived: Boolean

  """
  *The unique organization ID for this notification. Can be blank for targeted notifications
  """
  orgId: ID

  """The datetime to activate the notification & send it to the client"""
  startAt: DateTime
  type: NotificationEnum

  """*The userId that should see this notification"""
  userIds: [ID!]

  """How the user is affiliated with the task"""
  involvement: TaskInvolvementType

  """The taskId that now involves the userId"""
  taskId: ID!

  """The task that now involves the userId"""
  task: Task

  """The teamMemberId of the person that made the change"""
  changeAuthorId: ID

  """The TeamMember of the person that made the change"""
  changeAuthor: TeamMember
  teamId: ID!

  """The team the task is on"""
  team: Team!
}

"""
A notification alerting the user that a team they were on is now archived
"""
type NotifyTeamArchived implements Notification & TeamRemovedNotification {
  team: Team!

  """A shortid for the notification"""
  id: ID!

  """true if the notification has been archived, else false (or null)"""
  isArchived: Boolean

  """
  *The unique organization ID for this notification. Can be blank for targeted notifications
  """
  orgId: ID

  """The datetime to activate the notification & send it to the client"""
  startAt: DateTime
  type: NotificationEnum

  """*The userId that should see this notification"""
  userIds: [ID!]
}

"""An organization"""
type Organization {
  """The unique organization ID"""
  id: ID!

  """The datetime the organization was created"""
  createdAt: DateTime!

  """The safe credit card details"""
  creditCard: CreditCard

  """true if the viewer is the billing leader for the org"""
  isBillingLeader: Boolean!

  """The name of the organization"""
  name: String!

  """The org avatar"""
  picture: URL

  """all the teams the viewer is on in the organization"""
  teams: [Team!]!

  """The level of access to features on the parabol site"""
  tier: TierEnum

  """THe datetime the current billing cycle ends"""
  periodEnd: DateTime

  """The datetime the current billing cycle starts"""
  periodStart: DateTime

  """The total number of retroMeetings given to the team"""
  retroMeetingsOffered: Int! @deprecated(reason: "Unlimited retros for all!")

  """Number of retro meetings that can be run (if not pro)"""
  retroMeetingsRemaining: Int! @deprecated(reason: "Unlimited retros for all!")

  """The customerId from stripe"""
  stripeId: ID

  """The subscriptionId from stripe"""
  stripeSubscriptionId: ID

  """The last upcoming invoice email that was sent, null if never sent"""
  upcomingInvoiceEmailSentAt: DateTime

  """The datetime the organization was last updated"""
  updatedAt: DateTime
  organizationUsers(after: String, first: Int): OrganizationUserConnection!

  """The count of active & inactive users"""
  orgUserCount: OrgUserCount!

  """The leaders of the org"""
  billingLeaders: [User!]!
}

interface OrganizationNotification {
  id: ID
  type: NotificationEnum
}

union OrganizationSubscriptionPayload = AddOrgPayload | DowngradeToPersonalPayload | RemoveOrgUserPayload | SetOrgUserRoleAddedPayload | SetOrgUserRoleRemovedPayload | UpdateCreditCardPayload | UpdateOrgPayload | UpgradeToProPayload

"""organization-specific details about a user"""
type OrganizationUser {
  """orgId::userId"""
  id: ID!

  """
  true if the user is paused and the orgs are not being billed, else false
  """
  inactive: Boolean!

  """the datetime the user first joined the org"""
  joinedAt: DateTime!

  """
  The last moment a billing leader can remove the user from the org & receive a refund. Set to the subscription periodEnd
  """
  newUserUntil: DateTime!

  """FK"""
  orgId: ID!

  """The user attached to the organization"""
  organization: Organization!

  """if not a member, the datetime the user was removed from the org"""
  removedAt: DateTime

  """role of the user in the org"""
  role: OrgUserRole

  """FK"""
  userId: ID!

  """The user attached to the organization"""
  user: User!
}

"""A connection to a list of items."""
type OrganizationUserConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [OrganizationUserEdge!]!
}

"""An edge in a connection."""
type OrganizationUserEdge {
  """The item at the end of the edge"""
  node: OrganizationUser!

  """A cursor for use in pagination"""
  cursor: String!
}

type OrgUserCount {
  """The number of orgUsers who have an inactive flag"""
  inactiveUserCount: Int!

  """The number of orgUsers who do not have an inactive flag"""
  activeUserCount: Int!
}

"""The role of the org user"""
enum OrgUserRole {
  billingLeader
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

"""Information about pagination in a connection."""
type PageInfoDateCursor {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: DateTime

  """When paginating forwards, the cursor to continue."""
  endCursor: DateTime
}

type PhaseCompletePayload {
  """payload provided if the retro reflect phase was completed"""
  reflect: ReflectPhaseCompletePayload

  """payload provided if the retro grouping phase was completed"""
  group: GroupPhaseCompletePayload

  """payload provided if the retro voting phase was completed"""
  vote: VotePhaseCompletePayload
}

type PromoteFacilitatorPayload {
  error: StandardMutationError

  """Thea team currently running a meeting"""
  team: Team

  """The new meeting facilitator"""
  newFacilitator: TeamMember

  """The team member that disconnected"""
  disconnectedFacilitator: TeamMember
}

type PromoteNewMeetingFacilitatorPayload {
  error: StandardMutationError

  """The meeting in progress"""
  meeting: NewMeeting

  """The old meeting facilitator"""
  oldFacilitator: User
}

type PromoteToTeamLeadPayload {
  error: StandardMutationError
  team: Team
  oldLeader: TeamMember
  newLeader: TeamMember
}

"""A token for a user to be used on 1 or more teams"""
type Provider {
  """The ID of an object"""
  id: ID!

  """The access token to the service"""
  accessToken: ID!

  """The timestamp the provider was created"""
  createdAt: DateTime

  """True if the Provider is active. else false"""
  isActive: Boolean

  """
  *The id for the user used by the provider, eg SlackTeamId, GoogleUserId, githubLogin
  """
  providerUserId: ID

  """The username (or email) attached to the provider"""
  providerUserName: String

  """The name of the service"""
  service: IntegrationServiceEnum

  """*The team that the token is linked to"""
  teamId: ID

  """The timestamp the task was updated"""
  updatedAt: DateTime

  """The user that the access token is attached to"""
  userId: ID
}

"""A token for a user to be used on 1 or more teams"""
type ProviderMap {
  """The ID of an object"""
  id: ID!
  teamId: ID

  """All the big details associated with slack"""
  SlackIntegration: ProviderRow

  """All the big details associated with GitHub"""
  GitHubIntegration: ProviderRow
}

"""All the details about a particular provider"""
type ProviderRow {
  """composite keyID"""
  id: ID!

  """
  The access token attached to the userId. null if user does not have a token for the provider
  """
  accessToken: ID

  """
  The count of all the people on the team that have linked their account to the provider
  """
  userCount: Int!

  """The number of integrations under this provider for the team"""
  integrationCount: Int!

  """The username according to the provider"""
  providerUserName: String

  """The name of the service"""
  service: IntegrationServiceEnum
  teamId: ID
}

type Query {
  viewer: User
  verifiedInvitation(
    """The invitation token"""
    token: ID!
  ): VerifiedInvitationPayload
  authProviders(
    """the email to see if it exists as an oauth account"""
    email: ID!
  ): [String!]!
}

"""
sorts for the reflection group. default is sortOrder. sorting by voteCount filters out items without votes.
"""
enum ReflectionGroupSortEnum {
  voteCount
}

"""The meeting phase where all team members check in one-by-one"""
type ReflectPhase implements NewMeetingPhase {
  """shortid"""
  id: ID!

  """The type of phase"""
  phaseType: NewMeetingPhaseTypeEnum
  stages: [GenericMeetingStage!]!

  """foreign key. use focusedPhaseItem"""
  focusedPhaseItemId: ID

  """the phase item that the facilitator wants the group to focus on"""
  focusedPhaseItem: RetroPhaseItem

  """FK. The ID of the template used during the reflect phase"""
  promptTemplateId: ID!

  """The prompts used during the reflect phase"""
  reflectPrompts: [RetroPhaseItem!]!
  teamId: ID!
}

type ReflectPhaseCompletePayload {
  """a list of empty reflection groups to remove"""
  emptyReflectionGroupIds: [ID]
}

"""The team-specific templates for the reflection prompts"""
type ReflectTemplate {
  id: ID!
  createdAt: DateTime!

  """True if template can be used, else false"""
  isActive: Boolean!

  """The time of the meeting the template was last used"""
  lastUsedAt: DateTime

  """The name of the template"""
  name: String!

  """The prompts that are part of this template"""
  prompts: [RetroPhaseItem!]!

  """*Foreign key. The team this template belongs to"""
  teamId: ID!
  updatedAt: DateTime!
}

type RemoveAgendaItemPayload {
  error: StandardMutationError
  agendaItem: AgendaItem
}

type RemoveAtlassianAuthPayload {
  error: StandardMutationError

  """The ID of the authorization removed"""
  authId: ID
  teamId: ID

  """The user with updated atlassianAuth"""
  user: User
}

type RemoveGitHubRepoPayload {
  deletedId: ID
  error: StandardMutationError
  archivedTaskIds: [ID]
}

type RemoveOrgUserPayload {
  error: StandardMutationError

  """The organization the user was removed from"""
  organization: Organization

  """The teams the user was removed from"""
  teams: [Team]

  """The teamMembers removed"""
  teamMembers: [TeamMember]

  """The tasks that were archived or reassigned"""
  updatedTasks: [Task]

  """The user removed from the organization"""
  user: User

  """The notifications relating to a team the user was removed from"""
  removedTeamNotifications: [Notification]

  """The notifications that are no longer relevant to the removed org user"""
  removedOrgNotifications: [Notification]

  """The notifications for each team the user was kicked out of"""
  kickOutNotifications: [NotifyKickedOut]

  """The organization member that got removed"""
  removedOrgMember: OrganizationUser
  organizationUserId: String
}

type RemoveProviderPayload {
  error: StandardMutationError
  providerRow: ProviderRow

  """The globalIds of the removed integrations"""
  deletedIntegrationIds: [ID!]

  """The userId of the person who removed the provider"""
  userId: ID
  archivedTaskIds: [ID]
}

type RemoveReflectionPayload {
  error: StandardMutationError
  meeting: NewMeeting
  reflection: RetroReflection

  """The stages that were unlocked by navigating"""
  unlockedStages: [NewMeetingStage!]
}

type RemoveReflectTemplatePayload {
  error: StandardMutationError
  reflectTemplate: ReflectTemplate
  retroMeetingSettings: RetrospectiveMeetingSettings
}

type RemoveReflectTemplatePromptPayload {
  error: StandardMutationError
  reflectTemplate: ReflectTemplate
  prompt: ReflectTemplate
}

type RemoveSlackChannelPayload {
  error: StandardMutationError
  deletedId: ID!
}

type RemoveTeamMemberPayload {
  error: StandardMutationError

  """The team member removed"""
  teamMember: TeamMember

  """The team the team member was removed from"""
  team: Team

  """The tasks that got reassigned"""
  updatedTasks: [Task]

  """The user removed from the team"""
  user: User

  """Any notifications pertaining to the team that are no longer relevant"""
  removedNotifications: [Notification]

  """A notification if you were kicked out by the team leader"""
  kickOutNotification: NotifyKickedOut
}

type RenameReflectTemplatePayload {
  error: StandardMutationError
  reflectTemplate: ReflectTemplate
}

type RenameReflectTemplatePromptPayload {
  error: StandardMutationError
  prompt: RetroPhaseItem
}

type RequestFacilitatorPayload {
  error: StandardMutationError

  """The team member that wants to be the facilitator"""
  requestor: TeamMember
}

"""The stage where the team discusses a single theme"""
type RetroDiscussStage implements NewMeetingStage {
  """shortid"""
  id: ID!

  """The datetime the stage was completed"""
  endAt: DateTime

  """foreign key. try using meeting"""
  meetingId: ID!

  """The meeting this stage belongs to"""
  meeting: NewMeeting

  """
  true if the facilitator has completed this stage, else false. Should be boolean(endAt)
  """
  isComplete: Boolean

  """true if any meeting participant can navigate to this stage"""
  isNavigable: Boolean

  """true if the facilitator can navigate to this stage"""
  isNavigableByFacilitator: Boolean

  """The phase this stage belongs to"""
  phase: NewMeetingPhase

  """The type of the phase"""
  phaseType: NewMeetingPhaseTypeEnum

  """The datetime the stage was started"""
  startAt: DateTime

  """Number of times the facilitator has visited this stage"""
  viewCount: Int

  """foreign key. use reflectionGroup"""
  reflectionGroupId: ID

  """the group that is the focal point of the discussion"""
  reflectionGroup: RetroReflectionGroup

  """The sort order for reprioritizing discussion topics"""
  sortOrder: Float!
}

"""
A team-specific retro phase. Usually 3 or 4 exist per team, eg Good/Bad/Change, 4Ls, etc.
"""
type RetroPhaseItem implements CustomPhaseItem {
  """shortid"""
  id: ID!
  createdAt: DateTime!

  """The type of phase item"""
  phaseItemType: CustomPhaseItemTypeEnum

  """true if the phase item is currently used by the team, else false"""
  isActive: Boolean

  """foreign key. use the team field"""
  teamId: ID!

  """The team that owns this customPhaseItem"""
  team: Team
  updatedAt: DateTime!

  """the order of the items in the template"""
  sortOrder: Float!

  """FK for template"""
  templateId: ID!

  """The template that this prompt belongs to"""
  template: ReflectTemplate!

  """
  The title of the phase of the retrospective. Often a short version of the question
  """
  title: String!

  """
  The question to answer during the phase of the retrospective (eg What went well?)
  """
  question: String!

  """
  The description to the question for further context. A long version of the question.
  """
  description: String
}

"""A reflection created during the reflect phase of a retrospective"""
type RetroReflection {
  """shortid"""
  id: ID!

  """
  The ID of the group that the autogrouper assigned the reflection. Error rate = Sum(autoId != Id) / autoId.count()
  """
  autoReflectionGroupId: ID

  """The timestamp the meeting was created"""
  createdAt: DateTime

  """
  The userId that created the reflection (or unique Id if not a team member)
  """
  creatorId: ID

  """
  all the info associated with the drag state, if this reflection is currently being dragged
  """
  dragContext: DragContext

  """
  an array of all the socketIds that are currently editing the reflection
  """
  editorIds: [ID!]!

  """True if the reflection was not removed, else false"""
  isActive: Boolean

  """true if the reflection is being edited, else false"""
  isEditing: Boolean

  """
  true if the viewer (userId) is the creator of the retro reflection, else false
  """
  isViewerCreator: Boolean

  """The stringified draft-js content"""
  content: String!

  """
  The entities (i.e. nouns) parsed from the content and their respective salience
  """
  entities: [GoogleAnalyzedEntity!]!

  """The foreign key to link a reflection to its meeting"""
  meetingId: ID!

  """The retrospective meeting this reflection was created in"""
  meeting: RetrospectiveMeeting
  phaseItem: RetroPhaseItem!

  """
  The foreign key to link a reflection to its phaseItem. Immutable. For sorting, use phase item on the group.
  """
  retroPhaseItemId: ID!

  """The foreign key to link a reflection to its group"""
  reflectionGroupId: ID

  """The group the reflection belongs to, if any"""
  retroReflectionGroup: RetroReflectionGroup

  """
  The sort order of the reflection in the group (increments starting from 0)
  """
  sortOrder: Float!

  """The team that is running the meeting that contains this reflection"""
  team: RetrospectiveMeeting

  """
  The timestamp the meeting was updated. Used to determine how long it took to write a reflection
  """
  updatedAt: DateTime
}

"""A reflection created during the reflect phase of a retrospective"""
type RetroReflectionGroup {
  """shortid"""
  id: ID!

  """The timestamp the meeting was created"""
  createdAt: DateTime

  """True if the group has not been removed, else false"""
  isActive: Boolean

  """The foreign key to link a reflection group to its meeting"""
  meetingId: ID!

  """The retrospective meeting this reflection was created in"""
  meeting: RetrospectiveMeeting
  phaseItem: RetroPhaseItem
  reflections: [RetroReflection!]!

  """
  The foreign key to link a reflection group to its phaseItem. Immutable.
  """
  retroPhaseItemId: ID!

  """
  Our auto-suggested title, to be compared to the actual title for analytics
  """
  smartTitle: String

  """The sort order of the reflection group in the phase item"""
  sortOrder: Float!

  """The tasks created for this group in the discussion phase"""
  tasks: [Task!]!

  """The team that is running the retro"""
  team: Team

  """The title of the grouping of the retrospective reflections"""
  title: String

  """true if a user wrote the title, else false"""
  titleIsUserDefined: Boolean

  """The timestamp the meeting was updated at"""
  updatedAt: DateTime

  """
  A list of voterIds (userIds). Not available to team to preserve anonymity
  """
  voterIds: [ID!]!

  """The number of votes this group has received"""
  voteCount: Int!

  """The number of votes the viewer has given this group"""
  viewerVoteCount: Int
}

"""A retrospective meeting"""
type RetrospectiveMeeting implements NewMeeting {
  """The unique meeting id. shortid."""
  id: ID!

  """The timestamp the meeting was created"""
  createdAt: DateTime

  """The timestamp the meeting officially ended"""
  endedAt: DateTime

  """The location of the facilitator in the meeting"""
  facilitatorStageId: ID!

  """The userId (or anonymousId) of the most recent facilitator"""
  facilitatorUserId: ID!

  """The facilitator user"""
  facilitator: User!

  """The team members that were active during the time of the meeting"""
  meetingMembers: [MeetingMember]

  """The auto-incrementing meeting number for the team"""
  meetingNumber: Int!
  meetingType: MeetingTypeEnum!

  """
  The phases the meeting will go through, including all phase-specific state
  """
  phases: [NewMeetingPhase!]!

  """The time the meeting summary was emailed to the team"""
  summarySentAt: DateTime

  """foreign key for team"""
  teamId: ID!

  """The team that ran the meeting"""
  team: Team!

  """The last time a meeting was updated (stage completed, finished, etc)"""
  updatedAt: DateTime

  """The retrospective meeting member of the viewer"""
  viewerMeetingMember: RetrospectiveMeetingMember!

  """
  the threshold used to achieve the autogroup. Useful for model tuning. Serves as a flag if autogroup was used.
  """
  autoGroupThreshold: Float

  """
  the next smallest distance threshold to guarantee at least 1 more grouping will be achieved
  """
  nextAutoGroupThreshold: Float

  """The grouped reflections"""
  reflectionGroups(sortBy: ReflectionGroupSortEnum): [RetroReflectionGroup!]!

  """The settings that govern the retrospective meeting"""
  settings: RetrospectiveMeetingSettings!

  """The number of tasks generated in the meeting"""
  taskCount: Int!

  """The tasks created within the meeting"""
  tasks: [Task!]!

  """
  The sum total of the votes remaining for the meeting members that are present in the meeting
  """
  votesRemaining: Int!
}

"""All the meeting specifics for a user in a retro meeting"""
type RetrospectiveMeetingMember implements MeetingMember {
  """A composite of userId::meetingId"""
  id: ID!

  """true if present, false if absent, else null"""
  isCheckedIn: Boolean
  meetingId: ID
  meetingType: MeetingTypeEnum!
  teamId: ID
  user: User
  userId: ID

  """The last time a meeting was updated (stage completed, finished, etc)"""
  updatedAt: DateTime

  """The tasks assigned to members during the meeting"""
  tasks: [Task!]!
  votesRemaining: Int!
}

"""The retro-specific meeting settings"""
type RetrospectiveMeetingSettings implements TeamMeetingSettings {
  id: ID!

  """The type of meeting these settings apply to"""
  meetingType: MeetingTypeEnum

  """The broad phase types that will be addressed during the meeting"""
  phaseTypes: [NewMeetingPhaseTypeEnum!]!

  """FK"""
  teamId: ID!

  """The team these settings belong to"""
  team: Team

  """the team-specific questions to ask during a retro"""
  phaseItems: [CustomPhaseItem!]

  """
  The total number of votes each team member receives for the voting phase
  """
  totalVotes: Int!

  """
  The maximum number of votes a team member can vote for a single reflection group
  """
  maxVotesPerGroup: Int!

  """FK. The template that will be used to start the retrospective"""
  selectedTemplateId: ID!

  """The list of templates used to start a retrospective"""
  reflectTemplates: [ReflectTemplate!]!
}

input SegmentEventTrackOptions {
  teamId: ID
  orgId: ID

  """Used during the welcome wizard step 3"""
  inviteeCount: Int
}

type SelectRetroTemplatePayload {
  error: StandardMutationError
  retroMeetingSettings: RetrospectiveMeetingSettings!
}

type SetOrgUserRoleAddedPayload implements SetOrgUserRolePayload {
  error: StandardMutationError
  organization: Organization
  updatedOrgMember: OrganizationUser

  """If promoted, notify them and give them all other admin notifications"""
  notificationsAdded: [OrganizationNotification]
}

interface SetOrgUserRolePayload {
  error: StandardMutationError
  organization: Organization
  updatedOrgMember: OrganizationUser
}

type SetOrgUserRoleRemovedPayload implements SetOrgUserRolePayload {
  error: StandardMutationError
  organization: Organization
  updatedOrgMember: OrganizationUser

  """If demoted, notify them and remove all other admin notifications"""
  notificationsRemoved: [OrganizationNotification]
}

type SetPhaseFocusPayload {
  error: StandardMutationError
  meeting: RetrospectiveMeeting!
  reflectPhase: ReflectPhase!
}

"""
An integration that sends start/end meeting messages to a specified slack channel
"""
type SlackIntegration {
  """The ID of an object"""
  id: ID!

  """
  the id of the channel provided by the service, if available. Useful for fetching from their API
  """
  channelId: ID!

  """
  The name of the channel. Shared with all, updated when the integration owner looks at it
  """
  channelName: String

  """defaults to true. true if this is used to send notifications"""
  isActive: Boolean

  """The types of notifications the team wishes to receive"""
  notifications: [String]

  """*The team that cares about these annoucements"""
  teamId: ID!
}

"""A member of a team"""
type SoftTeamMember implements Assignee {
  """The teamMemberId or softTeamMemberId"""
  id: ID!

  """The name of the assignee"""
  preferredName: String!

  """foreign key to Team table"""
  teamId: ID!

  """The datetime the team was created"""
  createdAt: DateTime

  """The user email"""
  email: Email

  """
  True if this is still a soft team member, false if they were rejected or became a team member
  """
  isActive: Boolean

  """Tasks owned by the team member"""
  tasks(
    """the datetime cursor"""
    after: DateTime
    first: Int
  ): TaskConnection

  """The team this team member belongs to"""
  team: Team
}

type StandardMutationError {
  """The title of the error"""
  title: String

  """The full error"""
  message: String!
}

type StartDraggingReflectionPayload {
  error: StandardMutationError

  """
  The proposed start/end of a drag. Subject to race conditions, it is up to the client to decide to accept or ignore
  """
  dragContext: DragContext
  meeting: NewMeeting
  meetingId: ID
  reflection: RetroReflection
  reflectionId: ID
  teamId: ID
}

type StartMeetingPayload {
  error: StandardMutationError
  team: Team
}

type StartNewMeetingPayload {
  error: StandardMutationError
  team: Team
  meeting: NewMeeting
}

type StripeFailPaymentPayload {
  error: StandardMutationError
  organization: Organization

  """The notification to billing leaders stating the payment was rejected"""
  notification: NotifyPaymentRejected
}

type Subscription {
  agendaItemSubscription(teamId: ID!): AgendaItemSubscriptionPayload!
  githubMemberRemoved(teamId: ID!): GitHubMemberRemovedPayload!
  githubRepoAdded(teamId: ID!): AddGitHubRepoPayload!
  githubRepoRemoved(teamId: ID!): RemoveGitHubRepoPayload!
  integrationSubscription(teamId: ID!): IntegrationSubscriptionPayload!
  integrationJoined(service: IntegrationServiceEnum!, teamId: ID!): JoinIntegrationPayload!
  integrationLeft(service: IntegrationServiceEnum!, teamId: ID!): LeaveIntegrationPayload!
  newAuthToken: String
  notificationSubscription: NotificationSubscriptionPayload!
  organizationSubscription: OrganizationSubscriptionPayload!
  taskSubscription: TaskSubscriptionPayload!
  slackChannelAdded(teamId: ID!): AddSlackChannelPayload!
  slackChannelRemoved(teamId: ID!): RemoveSlackChannelPayload!
  teamSubscription: TeamSubscriptionPayload!
  teamMemberSubscription: TeamMemberSubscriptionPayload!
}

"""A past event that is important to the viewer"""
interface SuggestedAction {
  """shortid"""
  id: ID!

  """* The timestamp the action was created at"""
  createdAt: DateTime!

  """
  The priority of the suggested action compared to other suggested actions (smaller number is higher priority)
  """
  priority: Float

  """* The timestamp the action was removed at"""
  removedAt: DateTime!

  """The specific type of suggested action"""
  type: SuggestedActionTypeEnum!

  """* The userId this action is for"""
  userId: ID!

  """The user than can see this event"""
  user: User!
}

"""a suggestion to try a retro with your team"""
type SuggestedActionCreateNewTeam implements SuggestedAction {
  """shortid"""
  id: ID!

  """* The timestamp the action was created at"""
  createdAt: DateTime!

  """
  The priority of the suggested action compared to other suggested actions (smaller number is higher priority)
  """
  priority: Float

  """* The timestamp the action was removed at"""
  removedAt: DateTime!

  """The specific type of suggested action"""
  type: SuggestedActionTypeEnum!

  """* The userId this action is for"""
  userId: ID!

  """The user than can see this event"""
  user: User!
}

"""a suggestion to invite others to your team"""
type SuggestedActionInviteYourTeam implements SuggestedAction {
  """shortid"""
  id: ID!

  """* The timestamp the action was created at"""
  createdAt: DateTime!

  """
  The priority of the suggested action compared to other suggested actions (smaller number is higher priority)
  """
  priority: Float

  """* The timestamp the action was removed at"""
  removedAt: DateTime!

  """The specific type of suggested action"""
  type: SuggestedActionTypeEnum!

  """* The userId this action is for"""
  userId: ID!

  """The user than can see this event"""
  user: User!

  """The teamId that we suggest you should invite people to"""
  teamId: ID!

  """The team you should invite people to"""
  team: Team!
}

"""a suggestion to try a retro with your team"""
type SuggestedActionTryActionMeeting implements SuggestedAction {
  """shortid"""
  id: ID!

  """* The timestamp the action was created at"""
  createdAt: DateTime!

  """
  The priority of the suggested action compared to other suggested actions (smaller number is higher priority)
  """
  priority: Float

  """* The timestamp the action was removed at"""
  removedAt: DateTime!

  """The specific type of suggested action"""
  type: SuggestedActionTypeEnum!

  """* The userId this action is for"""
  userId: ID!

  """The user than can see this event"""
  user: User!

  """fk"""
  teamId: ID!

  """The team you should run an action meeting with"""
  team: Team!
}

"""a suggestion to try a retro with your team"""
type SuggestedActionTryRetroMeeting implements SuggestedAction {
  """shortid"""
  id: ID!

  """* The timestamp the action was created at"""
  createdAt: DateTime!

  """
  The priority of the suggested action compared to other suggested actions (smaller number is higher priority)
  """
  priority: Float

  """* The timestamp the action was removed at"""
  removedAt: DateTime!

  """The specific type of suggested action"""
  type: SuggestedActionTypeEnum!

  """* The userId this action is for"""
  userId: ID!

  """The user than can see this event"""
  user: User!

  """fk"""
  teamId: ID!

  """The team you should run a retro with"""
  team: Team!
}

"""a suggestion to invite others to your team"""
type SuggestedActionTryTheDemo implements SuggestedAction {
  """shortid"""
  id: ID!

  """* The timestamp the action was created at"""
  createdAt: DateTime!

  """
  The priority of the suggested action compared to other suggested actions (smaller number is higher priority)
  """
  priority: Float

  """* The timestamp the action was removed at"""
  removedAt: DateTime!

  """The specific type of suggested action"""
  type: SuggestedActionTypeEnum!

  """* The userId this action is for"""
  userId: ID!

  """The user than can see this event"""
  user: User!
}

"""The specific type of the suggested action"""
enum SuggestedActionTypeEnum {
  inviteYourTeam
  tryTheDemo
  tryRetroMeeting
  createNewTeam
  tryActionMeeting
}

interface SuggestedIntegration {
  id: ID!
  service: TaskServiceEnum!
}

"""The details associated with a task integrated with Jira"""
type SuggestedIntegrationJira implements SuggestedIntegration {
  id: ID!
  service: TaskServiceEnum!

  """
  The project key used by jira as a more human readable proxy for a projectId
  """
  projectKey: ID!

  """The name of the project as defined by jira"""
  projectName: ID!

  """The cloud ID that the project lives on"""
  cloudId: ID!

  """The full project document fetched from Jira"""
  remoteProject: JiraRemoteProject!
}

"""A long-term task shared across the team, assigned to a single user """
type Task {
  """shortid"""
  id: ID!

  """the agenda item that created this task, if any"""
  agendaId: ID

  """The body of the task. If null, it is a new task."""
  content: String!

  """The timestamp the task was created"""
  createdAt: DateTime

  """The userId that created the task"""
  createdBy: ID

  """a user-defined due date"""
  dueDate: DateTime

  """
  a list of users currently editing the task (fed by a subscription, so queries return null)
  """
  editors: [TaskEditorDetails]
  integration: TaskIntegration

  """true if this is assigned to a soft team member"""
  isSoftTask: Boolean

  """the foreign key for the meeting the task was created in"""
  meetingId: ID

  """
  the foreign key for the retrospective reflection group this was created in
  """
  reflectionGroupId: ID

  """the shared sort order for tasks on the team dash & user dash"""
  sortOrder: Float!

  """The status of the task"""
  status: TaskStatusEnum

  """The tags associated with the task"""
  tags: [String]

  """
  The id of the team (indexed). Needed for subscribing to archived tasks
  """
  teamId: ID!

  """The team this task belongs to"""
  team: Team!

  """The team member (or soft team member) that owns this task"""
  assignee: Assignee!

  """The id of the team member (or soft team member) assigned to this task"""
  assigneeId: ID!

  """The timestamp the task was updated"""
  updatedAt: DateTime

  """
  * The userId, index useful for server-side methods getting all tasks under a user
  """
  userId: ID
}

"""A connection to a list of items."""
type TaskConnection {
  """Page info with cursors coerced to ISO8601 dates"""
  pageInfo: PageInfoDateCursor

  """A list of edges."""
  edges: [TaskEdge!]!
}

"""An edge in a connection."""
type TaskEdge {
  """The item at the end of the edge"""
  node: Task!
  cursor: DateTime
}

type TaskEditorDetails {
  """The userId of the person editing the task"""
  userId: ID!

  """The name of the userId editing the task"""
  preferredName: String!
}

interface TaskIntegration {
  id: ID!
  service: TaskServiceEnum!
}

"""How a user is involved with a task (listed in hierarchical order)"""
enum TaskInvolvementType {
  ASSIGNEE
  MENTIONEE
}

"""The list of services for task integrations"""
enum TaskServiceEnum {
  GitHubIntegration
  jira
}

"""The status of the task"""
enum TaskStatusEnum {
  active
  stuck
  done
  future
}

union TaskSubscriptionPayload = ChangeTaskTeamPayload | CreateGitHubIssuePayload | CreateTaskPayload | DeleteTaskPayload | EditTaskPayload | EndMeetingPayload | RemoveOrgUserPayload | RemoveTeamMemberPayload | UpdateTaskPayload | UpdateTaskDueDatePayload

"""A team"""
type Team {
  """A shortid for the team"""
  id: ID!

  """The datetime the team was created"""
  createdAt: DateTime!

  """The userId that created the team. Non-null at v2.22.0+"""
  createdBy: ID

  """
  true if the underlying org has a validUntil date greater than now. if false, subs do not work
  """
  isPaid: Boolean

  """
  The current or most recent meeting number (also the number of meetings the team has had
  """
  meetingNumber: Int

  """The name of the team"""
  name: String!

  """The organization to which the team belongs"""
  orgId: ID!

  """Arbitrary tags that the team uses"""
  tags: [String]

  """The datetime the team was last updated"""
  updatedAt: DateTime

  """The checkIn greeting (fun language)"""
  checkInGreeting: MeetingGreeting

  """The checkIn question of the week"""
  checkInQuestion: String
  customPhaseItems: [CustomPhaseItem]

  """The unique Id of the active meeting"""
  meetingId: ID

  """The current facilitator teamMemberId for this meeting"""
  activeFacilitator: ID

  """The phase of the facilitator"""
  facilitatorPhase: ActionMeetingPhaseEnum

  """
  The current item number for the current phase for the facilitator, 1-indexed
  """
  facilitatorPhaseItem: Int

  """The outstanding invitations to join the team"""
  teamInvitations: [TeamInvitation!]

  """true if the viewer is the team lead, else false"""
  isLead: Boolean!

  """
  The phase of the meeting, usually matches the facilitator phase, be could be further along
  """
  meetingPhase: ActionMeetingPhaseEnum

  """
  The current item number for the current phase for the meeting, 1-indexed
  """
  meetingPhaseItem: Int

  """
  The team-specific settings for running all available types of meetings
  """
  meetingSettings(
    """the type of meeting for the settings"""
    meetingType: MeetingTypeEnum!
  ): TeamMeetingSettings!

  """The new meeting in progress, if any"""
  newMeeting: NewMeeting

  """The level of access to features on the parabol site"""
  tier: TierEnum
  organization: Organization!

  """The agenda items for the upcoming or current meeting"""
  agendaItems: [AgendaItem!]!

  """All of the tasks for this team"""
  tasks(
    """the datetime cursor"""
    after: DateTime
    first: Int
  ): TaskConnection

  """All the soft team members actively associated with the team"""
  softTeamMembers: [SoftTeamMember]

  """All the team members actively associated with the team"""
  teamMembers(
    """the field to sort the teamMembers by"""
    sortBy: String
  ): [TeamMember!]!

  """true if the team has been archived"""
  isArchived: Boolean
}

"""An invitation to become a team member"""
type TeamInvitation {
  """The unique invitation Id"""
  id: ID!

  """null if not accepted, else the datetime the invitation was accepted"""
  acceptedAt: DateTime

  """null if not accepted, else the userId that accepted the invitation"""
  acceptedBy: ID

  """The datetime the invitation was created"""
  createdAt: DateTime!

  """The email of the invitee"""
  email: Email!

  """The datetime the invitation expires. Changes when team is archived."""
  expiresAt: DateTime!

  """The userId of the person that sent the invitation"""
  invitedBy: ID!

  """The userId of the person that sent the invitation"""
  inviter: User!

  """The team invited to"""
  teamId: ID!

  """48-byte hex encoded random string"""
  token: ID!
}

"""The reason the invitation failed"""
enum TeamInvitationErrorEnum {
  accepted
  expired
  notFound
}

"""The team settings for a specific type of meeting"""
interface TeamMeetingSettings {
  id: ID!

  """The type of meeting these settings apply to"""
  meetingType: MeetingTypeEnum

  """The broad phase types that will be addressed during the meeting"""
  phaseTypes: [NewMeetingPhaseTypeEnum!]!

  """FK"""
  teamId: ID!

  """The team these settings belong to"""
  team: Team
}

"""A member of a team"""
type TeamMember implements Assignee {
  """An ID for the teamMember. userId::teamId"""
  id: ID!

  """The name of the assignee"""
  preferredName: String!

  """foreign key to Team table"""
  teamId: ID!

  """true if the user is a part of the team, false if they no longer are"""
  isNotRemoved: Boolean

  """Is user a team lead?"""
  isLead: Boolean

  """Is user a team facilitator?"""
  isFacilitator: Boolean

  """hide the agenda list on the dashboard"""
  hideAgenda: Boolean

  """The user email"""
  email: Email!

  """url of user’s profile picture"""
  picture: URL

  """The place in line for checkIn, regenerated every meeting"""
  checkInOrder: Int

  """true if the user is connected"""
  isConnected: Boolean

  """true if present, false if absent, null before check-in"""
  isCheckedIn: Boolean

  """true if this team member belongs to the user that queried it"""
  isSelf: Boolean!

  """The meeting specifics for the meeting the team member is currently in"""
  meetingMember(meetingId: ID): MeetingMember

  """foreign key to User table"""
  userId: ID!

  """The team this team member belongs to"""
  team: Team

  """The user for the team member"""
  user: User!

  """Tasks owned by the team member"""
  tasks(
    """the datetime cursor"""
    after: DateTime
    first: Int
  ): TaskConnection
}

union TeamMemberSubscriptionPayload = RemoveTeamMemberPayload | MeetingCheckInPayload | RemoveOrgUserPayload | UpdateUserProfilePayload

interface TeamNotification {
  id: ID
  type: NotificationEnum
}

interface TeamRemovedNotification {
  """A shortid for the notification"""
  id: ID!

  """true if the notification has been archived, else false (or null)"""
  isArchived: Boolean

  """
  *The unique organization ID for this notification. Can be blank for targeted notifications
  """
  orgId: ID

  """The datetime to activate the notification & send it to the client"""
  startAt: DateTime
  type: NotificationEnum

  """*The userId that should see this notification"""
  userIds: [ID!]
}

union TeamSubscriptionPayload = AcceptTeamInvitationPayload | AddTeamPayload | ArchiveTeamPayload | AutoGroupReflectionsPayload | CreateReflectionPayload | CreateReflectionGroupPayload | DowngradeToPersonalPayload | DragDiscussionTopicPayload | EndDraggingReflectionPayload | EditReflectionPayload | EndMeetingPayload | KillMeetingPayload | EndNewMeetingPayload | MoveMeetingPayload | NavigateMeetingPayload | NewMeetingCheckInPayload | PromoteFacilitatorPayload | PromoteNewMeetingFacilitatorPayload | PromoteToTeamLeadPayload | RequestFacilitatorPayload | RemoveOrgUserPayload | RemoveReflectionPayload | RemoveTeamMemberPayload | SelectRetroTemplatePayload | SetPhaseFocusPayload | StartDraggingReflectionPayload | StartMeetingPayload | StartNewMeetingPayload | UpdateCheckInQuestionPayload | UpdateCreditCardPayload | UpdateDragLocationPayload | UpdateNewCheckInQuestionPayload | UpdateReflectionContentPayload | UpdateReflectionGroupTitlePayload | UpdateTeamNamePayload | UpgradeToProPayload | VoteForReflectionGroupPayload | AddReflectTemplatePayload | AddReflectTemplatePromptPayload | MoveReflectTemplatePromptPayload | RemoveReflectTemplatePayload | RemoveReflectTemplatePromptPayload | RenameReflectTemplatePayload | RenameReflectTemplatePromptPayload

"""The pay tier of the team"""
enum TierEnum {
  personal
  pro
  enterprise
}

"""A past event that is important to the viewer"""
interface TimelineEvent {
  """shortid"""
  id: ID!

  """* The timestamp the event was created at"""
  createdAt: DateTime!

  """
  the number of times the user has interacted with (ie clicked) this event
  """
  interactionCount: Int!

  """
  The orgId this event is associated with. Null if not traceable to one org
  """
  orgId: ID

  """The organization this event is associated with"""
  organization: Organization

  """the number of times the user has seen this event"""
  seenCount: Int!

  """
  The teamId this event is associated with. Null if not traceable to one team
  """
  teamId: ID

  """The team that can see this event"""
  team: Team

  """The specific type of event"""
  type: TimelineEventEnum!

  """* The userId that can see this event"""
  userId: ID!

  """The user than can see this event"""
  user: User!
}

"""An event for a completed action meeting"""
type TimelineEventCompletedActionMeeting implements TimelineEvent {
  """shortid"""
  id: ID!

  """* The timestamp the event was created at"""
  createdAt: DateTime!

  """
  the number of times the user has interacted with (ie clicked) this event
  """
  interactionCount: Int!

  """The orgId this event is associated with"""
  orgId: ID!

  """The organization this event is associated with"""
  organization: Organization

  """the number of times the user has seen this event"""
  seenCount: Int!

  """The teamId this event is associated with"""
  teamId: ID!

  """The team that can see this event"""
  team: Team!

  """The specific type of event"""
  type: TimelineEventEnum!

  """* The userId that can see this event"""
  userId: ID!

  """The user than can see this event"""
  user: User!

  """The meeting that was completed"""
  meeting: Meeting!

  """The meetingId that was completed"""
  meetingId: ID!
}

"""An event for a completed retro meeting"""
type TimelineEventCompletedRetroMeeting implements TimelineEvent {
  """shortid"""
  id: ID!

  """* The timestamp the event was created at"""
  createdAt: DateTime!

  """
  the number of times the user has interacted with (ie clicked) this event
  """
  interactionCount: Int!

  """The orgId this event is associated with"""
  orgId: ID!

  """The organization this event is associated with"""
  organization: Organization

  """the number of times the user has seen this event"""
  seenCount: Int!

  """The teamId this event is associated with"""
  teamId: ID!

  """The team that can see this event"""
  team: Team!

  """The specific type of event"""
  type: TimelineEventEnum!

  """* The userId that can see this event"""
  userId: ID!

  """The user than can see this event"""
  user: User!

  """The meeting that was completed"""
  meeting: RetrospectiveMeeting!

  """The meetingId that was completed"""
  meetingId: ID!
}

"""A connection to a list of items."""
type TimelineEventConnection {
  """Page info with cursors coerced to ISO8601 dates"""
  pageInfo: PageInfoDateCursor

  """A list of edges."""
  edges: [TimelineEventEdge!]!
}

"""An edge in a connection."""
type TimelineEventEdge {
  """The item at the end of the edge"""
  node: TimelineEvent!
  cursor: DateTime
}

"""The specific type of event"""
enum TimelineEventEnum {
  retroComplete
  actionComplete
  joinedParabol
  createdTeam
}

"""An event for joining the app"""
type TimelineEventJoinedParabol implements TimelineEvent {
  """shortid"""
  id: ID!

  """* The timestamp the event was created at"""
  createdAt: DateTime!

  """
  the number of times the user has interacted with (ie clicked) this event
  """
  interactionCount: Int!

  """
  The orgId this event is associated with. Null if not traceable to one org
  """
  orgId: ID

  """The organization this event is associated with"""
  organization: Organization

  """the number of times the user has seen this event"""
  seenCount: Int!

  """
  The teamId this event is associated with. Null if not traceable to one team
  """
  teamId: ID

  """The team that can see this event"""
  team: Team

  """The specific type of event"""
  type: TimelineEventEnum!

  """* The userId that can see this event"""
  userId: ID!

  """The user than can see this event"""
  user: User!
}

"""An event triggered whenever a team is created"""
type TimelineEventTeamCreated implements TimelineEvent {
  """shortid"""
  id: ID!

  """* The timestamp the event was created at"""
  createdAt: DateTime!

  """
  the number of times the user has interacted with (ie clicked) this event
  """
  interactionCount: Int!

  """The orgId this event is associated with"""
  orgId: ID!

  """The organization this event is associated with"""
  organization: Organization

  """the number of times the user has seen this event"""
  seenCount: Int!

  """
  The teamId this event is associated with. Null if not traceable to one team
  """
  teamId: ID!

  """The team that can see this event"""
  team: Team!

  """The specific type of event"""
  type: TimelineEventEnum!

  """* The userId that can see this event"""
  userId: ID!

  """The user than can see this event"""
  user: User!
}

input UpdateAgendaItemInput {
  """The unique agenda item ID, composed of a teamId::shortid"""
  id: ID!

  """The content of the agenda item"""
  content: String

  """
  true until the agenda item has been marked isComplete and the meeting has ended
  """
  isActive: Boolean

  """
  true if the agenda item has been addressed in a meeting (will have a strikethrough or similar)
  """
  isComplete: Boolean

  """The sort order of the agenda item in the list"""
  sortOrder: Float
}

type UpdateAgendaItemPayload {
  agendaItem: AgendaItem
  error: StandardMutationError
}

type UpdateCheckInQuestionPayload {
  error: StandardMutationError
  team: Team
}

type UpdateCreditCardPayload {
  error: StandardMutationError

  """The organization that received the updated credit card"""
  organization: Organization

  """The teams that are now paid up"""
  teamsUpdated: [Team]
}

input UpdateDragLocationInput {
  clientHeight: Float!
  clientWidth: Float!

  """The primary key of the item being drug"""
  sourceId: ID!

  """The estimated destination of the item being drug"""
  targetId: ID

  """The teamId to broadcast the message to"""
  teamId: ID!
  coords: Coords2DInput!

  """The offset from the targetId"""
  targetOffset: Coords2DInput
}

type UpdateDragLocationPayload {
  clientHeight: Float!
  clientWidth: Float!

  """The primary key of the item being drug"""
  sourceId: ID!

  """The estimated destination of the item being drug"""
  targetId: ID
  coords: Coords2D!

  """The offset from the targetId"""
  targetOffset: Coords2D
  userId: ID!
}

input UpdatedTeamInput {
  id: ID

  """The name of the team"""
  name: String

  """A link to the team’s profile image."""
  picture: URL
}

type UpdateNewCheckInQuestionPayload {
  error: StandardMutationError
  meeting: NewMeeting
}

input UpdateOrgInput {
  """The unique action ID"""
  id: ID!

  """The name of the org"""
  name: String

  """The org avatar"""
  picture: URL
}

type UpdateOrgPayload {
  error: StandardMutationError

  """The updated org"""
  organization: Organization
}

type UpdateReflectionContentPayload {
  error: StandardMutationError
  meeting: NewMeeting
  reflection: RetroReflection
}

type UpdateReflectionGroupTitlePayload {
  error: StandardMutationError
  meeting: NewMeeting
  reflectionGroup: RetroReflectionGroup
}

type UpdateTaskDueDatePayload {
  error: StandardMutationError
  task: Task
}

input UpdateTaskInput {
  """The task id"""
  id: ID
  content: String
  sortOrder: Float
  status: TaskStatusEnum

  """The teamMemberId or softTeamMemberId"""
  assigneeId: ID
}

type UpdateTaskPayload {
  error: StandardMutationError
  task: Task

  """If a task was just turned private, this its ID, else null"""
  privatizedTaskId: ID
  addedNotification: NotifyTaskInvolves
  removedNotification: NotifyTaskInvolves
}

type UpdateTeamNamePayload {
  error: StandardMutationError
  team: Team
}

input UpdateUserProfileInput {
  """A link to the user’s profile image."""
  picture: URL

  """The name, as confirmed by the user"""
  preferredName: String
}

type UpdateUserProfilePayload {
  error: StandardMutationError
  user: User

  """The updated team members"""
  teamMembers: [TeamMember]
}

type UpgradeToProPayload {
  error: StandardMutationError

  """The new Pro Org"""
  organization: Organization

  """The updated teams under the org"""
  teams: [Team]
}

scalar URL

"""The user account profile"""
type User {
  """The userId provided by auth0"""
  id: ID

  """The auth for the viewer"""
  atlassianAuth(
    """The teamId for the atlassian auth token"""
    teamId: ID!
  ): AtlassianAuth

  """Array of identifier + ip pairs"""
  blockedFor: [BlockedUserType]

  """The timestamp of the user was cached"""
  cachedAt: DateTime

  """The timestamp when the cached user expires"""
  cacheExpiresAt: DateTime

  """The socketIds that the user is currently connected with"""
  connectedSockets: [ID]

  """The timestamp the user was created"""
  createdAt: DateTime

  """The user email"""
  email: Email!

  """true if email is verified, false otherwise"""
  emailVerified: Boolean

  """Any super power given to the user via a super user"""
  featureFlags: UserFeatureFlags!

  """
  An array of objects with information about the user's identities.
        More than one will exists in case accounts are linked
  """
  identities: [AuthIdentityType]

  """true if the user is currently online"""
  isConnected: Boolean

  """The number of logins for this user"""
  loginsCount: Int

  """Name associated with the user"""
  name: String

  """the most important actions for the user to perform"""
  suggestedActions: [SuggestedAction!]!

  """The timeline of important events for the viewer"""
  timeline(
    """the datetime cursor"""
    after: DateTime

    """the number of timeline events to return"""
    first: Int!
  ): TimelineEventConnection!

  """Nickname associated with the user"""
  nickname: String

  """url of user’s profile picture"""
  picture: URL

  """The timestamp the user was last updated"""
  updatedAt: DateTime

  """the ID of the newest feature, null if the user has dismissed it"""
  newFeatureId: ID

  """The new feature released by Parabol. null if the user already hid it"""
  newFeature: NewFeatureBroadcast

  """The last time the user connected via websocket"""
  lastSeenAt: DateTime

  """
  true if the user is not currently being billed for service. removed on every websocket handshake
  """
  inactive: Boolean

  """The application-specific name, defaults to nickname"""
  preferredName: String!
  archivedTasks(
    """the datetime cursor"""
    after: DateTime
    first: Int

    """The unique team ID"""
    teamId: ID!
  ): TaskConnection
  archivedTasksCount(
    """The unique team ID"""
    teamId: ID!
  ): Int

  """list of git hub repos available to the viewer"""
  githubRepos(
    """The unique team Id"""
    teamId: ID!
  ): [GitHubIntegration!]!

  """get an integration provider belonging to the user"""
  integrationProvider(
    """The unique team member Id"""
    teamId: ID!

    """The name of the service"""
    service: IntegrationServiceEnum!
  ): Provider
  invoices(
    """the datetime cursor"""
    after: DateTime
    first: Int

    """The id of the organization"""
    orgId: ID!
  ): InvoiceConnection
  invoiceDetails(
    """The id of the invoice"""
    invoiceId: ID!
  ): Invoice

  """A previous meeting that the user was in (present or absent)"""
  meeting(
    """The meeting ID"""
    meetingId: ID!
  ): Meeting

  """
  The meeting member associated with this user, if a meeting is currently in progress
  """
  meetingMember(
    """The specific meeting ID"""
    meetingId: ID

    """The teamId of the meeting currently in progress"""
    teamId: ID
  ): MeetingMember

  """A previous meeting that the user was in (present or absent)"""
  newMeeting(
    """The meeting ID"""
    meetingId: ID!
  ): NewMeeting!

  """all the notifications for a single user"""
  notifications(after: String, first: Int): NotificationConnection

  """The list of providers as seen on the integrations page"""
  providerMap(
    """The unique team member Id"""
    teamId: ID!
  ): ProviderMap!

  """paginated list of slackChannels"""
  slackChannels(
    """The unique team Id"""
    teamId: ID!
  ): [SlackIntegration!]!

  """get a single organization and the count of users by status"""
  organization(
    """the orgId"""
    orgId: ID!
  ): Organization

  """The connection between a user and an organization"""
  organizationUser(
    """the orgId"""
    orgId: ID!
  ): OrganizationUser

  """A single user that is connected to a single organization"""
  organizationUsers: [OrganizationUser!]!

  """Get the list of all organizations a user belongs to"""
  organizations: [Organization!]!

  """The integrations that the user would probably like to use"""
  suggestedIntegrations(
    """a teamId to use as a filter to provide more accurate suggestions"""
    teamId: ID
  ): [SuggestedIntegration!]!
  tasks(
    """the datetime cursor"""
    after: DateTime
    first: Int

    """The unique team ID"""
    teamId: ID
  ): TaskConnection!

  """A query for a team"""
  team(
    """The team ID for the desired team"""
    teamId: ID!
  ): Team

  """
  The invitation sent to the user, even if it was sent before they were a user
  """
  teamInvitation(
    """The teamId to check for the invitation"""
    teamId: ID!
  ): TeamInvitation

  """all the teams the user is on that the viewer can see."""
  teams: [Team!]!

  """The team member associated with this user"""
  teamMember(
    """The team the user is on"""
    teamId: ID!
  ): TeamMember

  """all the teams the user is a part of that the viewer can see"""
  tms: [ID]
}

"""The user account profile"""
type UserFeatureFlags {
  """true if the user has access to retro meeting video"""
  video: Boolean

  """true if jira is allowed"""
  jira: Boolean
}

"""A flag to give an individual user super powers"""
enum UserFlagEnum {
  video
  jira
}

type VerifiedInvitationPayload {
  errorType: TeamInvitationErrorEnum

  """
  The name of the person that sent the invitation, present if errorType is expired
  """
  inviterName: String

  """
  The email of the person that send the invitation, present if errorType is expired
  """
  inviterEmail: String

  """true if the mx record is hosted by google, else falsy"""
  isGoogle: Boolean

  """The valid invitation, if any"""
  teamInvitation: TeamInvitation

  """name of the inviting team, present if invitation exists"""
  teamName: String

  """The userId of the invitee, if already a parabol user"""
  userId: ID

  """The invitee, if already a parabol user, present if errorType is null"""
  user: User
}

type VoteForReflectionGroupPayload {
  error: StandardMutationError
  meeting: RetrospectiveMeeting
  meetingMember: RetrospectiveMeetingMember
  reflectionGroup: RetroReflectionGroup

  """The stages that were locked or unlocked by having at least 1 vote"""
  unlockedStages: [NewMeetingStage!]
}

type VotePhaseCompletePayload {
  """the current meeting"""
  meeting: RetrospectiveMeeting
}
